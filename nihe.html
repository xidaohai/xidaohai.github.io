<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>专业曲线拟合分析工具 | Pro Curve Fitting</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/regression@2.0.1/dist/regression.min.js"></script>
    <style>
        :root {
            --bg-body: #f0f2f5;
            --bg-card: #ffffff;
            --bg-input: #ffffff;
            --bg-hover: #f9fafb;
            --bg-active: #eff6ff;
            --text-primary: #1f2937;
            --text-secondary: #6b7280;
            --primary-color: #2563eb;
            --accent-color: #059669;
            --danger-color: #dc2626;
            --border-color: #e5e7eb;
            --chart-grid: #f3f4f6;
            --chart-text: #666666;
            --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            --scrollbar-track: #f1f1f1;
            --scrollbar-thumb: #c1c1c1;
            --scrollbar-thumb-hover: #a8a8a8;
            --sidebar-width: 320px;
        }

        [data-theme="dark"] {
            --bg-body: #111827;
            --bg-card: #1f2937;
            --bg-input: #374151;
            --bg-hover: #374151;
            --bg-active: #1e3a8a;
            --text-primary: #f9fafb;
            --text-secondary: #9ca3af;
            --primary-color: #3b82f6;
            --accent-color: #10b981;
            --danger-color: #ef4444;
            --border-color: #374151;
            --chart-grid: #374151;
            --chart-text: #9ca3af;
            --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.3);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.5);
            --scrollbar-track: #2d3748;
            --scrollbar-thumb: #4a5568;
            --scrollbar-thumb-hover: #718096;
        }
        
        /* --- 全局滚动条样式优化 --- */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: var(--scrollbar-track); 
            border-radius: 4px;
        }
         
        ::-webkit-scrollbar-thumb {
            background: var(--scrollbar-thumb); 
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: var(--scrollbar-thumb-hover); 
        }
        
        /* Firefox 适配 */
        * {
            scrollbar-width: thin;
            scrollbar-color: var(--scrollbar-thumb) var(--scrollbar-track);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
        }
        
        body {
            background-color: var(--bg-body);
            color: var(--text-primary);
            line-height: 1.5;
            padding: 20px;
            height: 100vh;
            overflow: hidden; 
            display: flex;
            flex-direction: column;
            transition: background-color 0.3s, color 0.3s;
        }

        header {
            background: var(--bg-card);
            padding: 15px 25px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
            box-shadow: var(--shadow-sm);
            z-index: 100;
            transition: background-color 0.3s, border-color 0.3s;
        }

        h1 {
            font-size: 1.25rem;
            font-weight: 700;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .badge {
            font-size: 0.75rem;
            background: var(--primary-color);
            color: white;
            padding: 2px 8px;
            border-radius: 4px;
            font-weight: 500;
        }

        /* 参考表下拉菜单样式 */
        .nav-item-container {
            position: relative;
            display: flex;
            align-items: center;
        }

        .reference-dropdown {
            position: absolute;
            top: 100%;
            right: 0;
            width: 480px;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            box-shadow: var(--shadow-md);
            padding: 20px;
            display: none; /* 默认隐藏 */
            opacity: 0;
            transform: translateY(10px);
            transition: opacity 0.2s, transform 0.2s;
            z-index: 1000;
            margin-top: 10px;
        }

        /* 悬停显示 */
        .nav-item-container:hover .reference-dropdown {
            display: block;
            opacity: 1;
            transform: translateY(0);
        }

        /* 连接区域，防止鼠标移出按钮间隙时菜单消失 */
        .nav-item-container::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 0;
            width: 100%;
            height: 10px;
            background: transparent;
        }

        .ref-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .ref-section h4 {
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-bottom: 10px;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 5px;
            font-weight: 600;
        }

        .ref-item {
            display: flex;
            justify-content: space-between;
            padding: 6px 0;
            font-size: 0.85rem;
            color: var(--text-primary);
        }

        .ref-formula {
            font-family: 'Times New Roman', serif;
            font-style: italic;
            color: var(--primary-color);
            background: var(--bg-hover);
            padding: 2px 6px;
            border-radius: 4px;
        }

        .chart-icons-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .mini-chart-card {
            background: var(--bg-hover);
            border-radius: 6px;
            padding: 10px;
            text-align: center;
            transition: transform 0.2s;
        }
        .mini-chart-card:hover {
            transform: translateY(-2px);
            background: var(--bg-active);
        }

        .mini-chart-svg {
            width: 100%;
            height: 40px;
            stroke: var(--text-primary);
            stroke-width: 2;
            fill: none;
        }

        .mini-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-top: 5px;
            display: block;
        }

        .main-layout {
            display: grid;
            grid-template-columns: var(--sidebar-width) 14px 1fr;
            grid-template-rows: 1fr;
            gap: 0; 
            height: calc(100vh - 80px);
            padding-top: 20px;
            overflow: hidden;
        }

        .sidebar {
            background: var(--bg-card);
            border-radius: 8px;
            border: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-shadow: var(--shadow-sm);
            min-width: 0;
            transition: background-color 0.3s, border-color 0.3s;
        }

        .panel-header {
            padding: 15px;
            border-bottom: 1px solid var(--border-color);
            font-weight: 600;
            background: var(--bg-hover);
            color: var(--text-secondary);
            font-size: 0.9rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background-color 0.3s, border-color 0.3s;
        }

        .panel-content {
            padding: 15px;
            overflow-y: auto;
            flex: 1;
            overflow-x: hidden; 
        }

        .input-row {
            display: grid;
            grid-template-columns: 1fr 1fr auto;
            gap: 8px;
            margin-bottom: 15px;
        }

        input[type="number"], input[type="text"] {
            width: 100%;
            padding: 8px;
            border: 1px solid var(--border-color);
            background-color: var(--bg-input);
            color: var(--text-primary);
            border-radius: 4px;
            font-size: 0.9rem;
            transition: all 0.2s;
        }

        input[type="number"]:focus, input[type="text"]:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.1);
        }

        button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }

        .btn-primary { background: var(--primary-color); color: white; }
        .btn-primary:hover { filter: brightness(1.1); }
        
        .btn-danger { background: var(--bg-card); color: var(--danger-color); border: 1px solid var(--danger-color); }
        .btn-danger:hover { background: var(--bg-hover); opacity: 0.8; }

        .btn-ghost { background: transparent; color: var(--text-secondary); }
        .btn-ghost:hover { color: var(--danger-color); }
        
        .btn-icon-only {
            background: transparent;
            color: var(--text-secondary);
            padding: 8px;
            border-radius: 50%;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid var(--border-color);
            cursor: pointer;
            transition: all 0.2s;
        }
        .btn-icon-only:hover {
            background-color: var(--bg-hover);
            color: var(--primary-color);
            border-color: var(--primary-color);
        }

        .btn-group {
            display: flex;
            gap: 8px;
            margin-top: 15px;
            border-top: 1px solid var(--border-color);
            padding-top: 15px;
            flex-wrap: wrap;
        }
        
        .btn-outline {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            flex: 1;
            min-width: 60px;
        }
        .btn-outline:hover {
            background: var(--bg-hover);
            border-color: var(--primary-color);
            color: var(--primary-color);
        }

        .data-table-container {
            border: 1px solid var(--border-color);
            border-radius: 4px;
            max-height: 250px;
            overflow-y: auto;
            overflow-x: hidden;
        }

        .data-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 12px;
            border-bottom: 1px solid var(--border-color);
            font-size: 0.85rem;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .data-row:hover {
            background-color: var(--bg-hover);
        }

        .data-row.editing {
            background-color: var(--bg-active);
        }

        .data-row:last-child { border-bottom: none; }
        .data-row:nth-child(even) { background-color: var(--bg-hover); }

        .edit-input {
            width: 60px;
            padding: 2px 4px;
            border: 1px solid var(--primary-color);
            border-radius: 3px;
            background: var(--bg-input);
            color: var(--text-primary);
            font-size: 0.8rem;
        }

        .edit-buttons {
            display: flex;
            gap: 4px;
        }

        .edit-btn {
            padding: 2px 6px;
            font-size: 0.7rem;
            border-radius: 3px;
        }

        .chart-controls {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid var(--border-color);
        }

        .control-item {
            margin-bottom: 12px;
        }
        
        .control-label {
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-bottom: 4px;
            white-space: nowrap;
        }

        input[type="range"] {
            width: 100%;
            accent-color: var(--primary-color);
            cursor: pointer;
        }

        .content-area {
            display: flex;
            flex-direction: column;
            gap: 0;
            overflow: hidden;
            min-width: 0;
        }

        .chart-wrapper {
            flex: 0 0 auto;
            height: 55%; 
            background: var(--bg-card);
            border-radius: 8px;
            border: 1px solid var(--border-color);
            padding: 15px;
            position: relative;
            min-height: 20px;
            box-shadow: var(--shadow-sm);
            overflow: hidden;
            transition: background-color 0.3s, border-color 0.3s;
        }

        .resizer-horizontal {
            height: 14px;
            background: transparent;
            cursor: row-resize;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-shrink: 0;
            z-index: 20;
            margin: 4px 0;
        }

        .handle-horizontal {
            width: 48px;
            height: 6px;
            background-color: #d1d5db;
            border-radius: 3px;
            transition: background-color 0.2s, transform 0.2s;
            position: relative;
        }
        
        .handle-horizontal::after {
            content: '';
            position: absolute;
            top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 100%; height: 100%;
            border-radius: 3px;
            box-shadow: inset 0 0 2px rgba(0,0,0,0.1);
        }

        .resizer-horizontal:hover .handle-horizontal {
            background-color: var(--primary-color);
            transform: scaleY(1.2);
        }
        .resizer-horizontal:active .handle-horizontal { background-color: #1d4ed8; }

        .resizer-vertical {
            width: 14px;
            height: 100%;
            background: transparent;
            cursor: col-resize;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 20;
        }

        .handle-vertical {
            width: 6px;
            height: 48px;
            background-color: #d1d5db;
            border-radius: 3px;
            transition: background-color 0.2s, transform 0.2s;
            position: relative;
        }

        .handle-vertical::after {
            content: '';
            position: absolute;
            top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 100%; height: 100%;
            border-radius: 3px;
            box-shadow: inset 0 0 2px rgba(0,0,0,0.1);
        }

        .resizer-vertical:hover .handle-vertical {
            background-color: var(--primary-color);
            transform: scaleX(1.2);
        }
        .resizer-vertical:active .handle-vertical { background-color: #1d4ed8; }

        .formulas-wrapper {
            flex: 1;
            background: var(--bg-card);
            border-radius: 8px;
            border: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-shadow: var(--shadow-sm);
            min-height: 0;
            transition: background-color 0.3s, border-color 0.3s;
        }

        .formulas-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(450px, 1fr));
            gap: 15px;
            padding: 15px;
            overflow-y: auto;
        }

        .formula-card {
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 12px;
            transition: all 0.2s;
            position: relative;
            background: var(--bg-card);
            color: var(--text-primary);
        }

        .formula-card:hover {
            border-color: var(--primary-color);
            box-shadow: var(--shadow-md);
            transform: translateY(-2px);
        }

        .formula-card.active {
            border-color: var(--primary-color);
            background-color: var(--bg-active);
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-secondary);
        }

        .r2-badge {
            background: rgba(16, 185, 129, 0.1);
            color: var(--accent-color);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: monospace;
        }

        .formula-container-row {
            display: flex;
            align-items: stretch;
            gap: 8px;
            margin-bottom: 8px;
        }

        .formula-box {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0; 
        }

        .formula-box-label {
            font-size: 0.7rem;
            color: var(--text-secondary);
            margin-bottom: 4px;
            white-space: nowrap;
        }

        .math-display-box {
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            padding: 8px;
            border-radius: 4px;
            overflow-x: auto;
            white-space: nowrap;
            height: 100%; 
            display: flex;
            align-items: center;
        }

        .raw-box {
            background: var(--bg-hover);
            color: var(--text-primary);
            border: 1px solid transparent;
        }

        .beautified-box {
            background: rgba(245, 158, 11, 0.1);
            color: #d97706;
            border: 1px solid rgba(245, 158, 11, 0.3);
            font-weight: 600;
        }
        
        [data-theme="dark"] .beautified-box {
            color: #fbbf24;
        }

        .arrow-separator {
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-secondary);
            font-size: 1.2rem;
            padding-top: 16px; 
        }

        .optimization-note {
            color: var(--text-secondary);
            font-size: 0.75rem;
            margin-top: 6px;
            font-style: italic;
            border-top: 1px dashed var(--border-color);
            padding-top: 6px;
        }

        .btn-lock {
            position: relative;
            padding: 8px 12px;
            border-radius: 4px;
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 5px;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
        }
        
        .btn-lock:hover {
            background: var(--bg-hover);
        }
        
        .btn-lock.active {
            background: var(--primary-color);
            color: white;
            border-color: var(--primary-color);
        }
        
        .btn-lock.active:hover {
            filter: brightness(1.1);
        }
        
        .file-input-wrapper {
            position: relative;
            display: inline-block;
            flex: 1;
        }
        
        .file-input-wrapper input[type="file"] {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0;
            cursor: pointer;
        }
        
        .btn-import {
            width: 100%;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            padding: 8px 16px;
            border-radius: 4px;
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }
        
        .btn-import:hover {
            background: var(--bg-hover);
            border-color: var(--primary-color);
            color: var(--primary-color);
        }

        .zoom-hint {
            position: absolute;
            bottom: 10px;
            left: 10px;
            background: var(--bg-card);
            border-radius: 6px;
            padding: 6px 12px;
            font-size: 0.75rem;
            color: var(--text-secondary);
            box-shadow: var(--shadow-sm);
            border: 1px solid var(--border-color);
            z-index: 10;
        }

        .fit-category {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-top: 4px;
        }
        
        .fit-subtype {
            font-size: 0.7rem;
            color: var(--text-secondary);
            font-style: italic;
        }

        @media (max-width: 768px) {
            .main-layout {
                display: flex; 
                flex-direction: column;
                gap: 10px;
                overflow-y: auto;
            }
            body { overflow: auto; height: auto; }
            .chart-wrapper { height: 350px !important; flex: none; }
            .resizer-horizontal, .resizer-vertical { display: none; }
            .sidebar { width: 100% !important; }
        }
        
        @media (max-width: 600px) {
            .formula-container-row { flex-direction: column; }
            .arrow-separator {
                padding-top: 0;
                transform: rotate(90deg);
                height: 20px;
            }
        }
    </style>
</head>
<body>

    <header>
        <h1>
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 3v18h18"/><path d="M18 17l-6-11-6 7"/></svg>
            CurveLab <span class="badge">XDH</span>
        </h1>
        
        <div style="display: flex; align-items: center; gap: 15px;">
            <div style="font-size: 0.85rem; color: var(--text-secondary);" class="subtitle-text">
                专业严谨 · 逻辑分析 · 优美拟合
            </div>
            
            <div class="nav-item-container">
                <button class="btn-icon-only" title="灵感参考表">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 18h6"/><path d="M10 22h4"/><path d="M15.09 14c.18-.9.66-1.68 1.35-2.25 2-1.66 2.56-4.6.57-6.95C15.3 2.62 12.04 1.76 9.4 3.32 6.57 5.03 5.6 8.92 7.22 11.75c.69.57 1.17 1.35 1.35 2.25"/></svg>
                </button>
                
                <div class="reference-dropdown">
                    <div class="ref-grid">
                        <div class="ref-section">
                            <h4>经典物理/数学模型</h4>
                            <div class="ref-item">
                                <span>自由落体</span>
                                <span class="ref-formula">h = ½gt²</span>
                            </div>
                            <div class="ref-item">
                                <span>牛顿第二定律</span>
                                <span class="ref-formula">F = ma</span>
                            </div>
                            <div class="ref-item">
                                <span>胡克定律</span>
                                <span class="ref-formula">F = kx</span>
                            </div>
                            <div class="ref-item">
                                <span>复利增长</span>
                                <span class="ref-formula">A = P(1+r)ᵗ</span>
                            </div>
                            <div class="ref-item">
                                <span>圆面积</span>
                                <span class="ref-formula">S = πr²</span>
                            </div>
                            <div class="ref-item">
                                <span>正态分布</span>
                                <span class="ref-formula">e⁻ˣ²</span>
                            </div>
                            <div class="ref-item">
                                <span>欧姆定律</span>
                                <span class="ref-formula">V = IR</span>
                            </div>
                            <div class="ref-item">
                                <span>能量守恒</span>
                                <span class="ref-formula">E = ½mv²</span>
                            </div>
                            <div class="ref-item">
                                <span>理想气体</span>
                                <span class="ref-formula">PV = nRT</span>
                            </div>
                            <div class="ref-item">
                                <span>库仑定律</span>
                                <span class="ref-formula">F = kq₁q₂/r²</span>
                            </div>
                            <div class="ref-item">
                                <span>热传导</span>
                                <span class="ref-formula">Q = kAΔT/d</span>
                            </div>
                            <div class="ref-item">
                                <span>简谐运动</span>
                                <span class="ref-formula">x = Acos(ωt+φ)</span>
                            </div>
                        </div>

                        <div class="ref-section">
                            <h4>常见数据形态</h4>
                            <div class="chart-icons-grid">
                                <div class="mini-chart-card">
                                    <svg class="mini-chart-svg" viewBox="0 0 100 50">
                                        <path d="M10,40 L90,10" />
                                    </svg>
                                    <span class="mini-label">线性增长 (Linear)</span>
                                </div>
                                <div class="mini-chart-card">
                                    <svg class="mini-chart-svg" viewBox="0 0 100 50">
                                        <path d="M10,40 Q50,40 90,10" />
                                    </svg>
                                    <span class="mini-label">指数爆发 (Exp)</span>
                                </div>
                                <div class="mini-chart-card">
                                    <svg class="mini-chart-svg" viewBox="0 0 100 50">
                                        <path d="M10,40 Q30,10 90,10" />
                                    </svg>
                                    <span class="mini-label">对数饱和 (Log)</span>
                                </div>
                                <div class="mini-chart-card">
                                    <svg class="mini-chart-svg" viewBox="0 0 100 50">
                                        <path d="M10,25 Q30,5 50,25 T90,25" />
                                    </svg>
                                    <span class="mini-label">周期波动 (Wave)</span>
                                </div>
                                <div class="mini-chart-card">
                                    <svg class="mini-chart-svg" viewBox="0 0 100 50">
                                        <path d="M10,40 L30,10 L50,40 L70,10 L90,40" />
                                    </svg>
                                    <span class="mini-label">振荡衰减 (Oscillation)</span>
                                </div>
                                <div class="mini-chart-card">
                                    <svg class="mini-chart-svg" viewBox="0 0 100 50">
                                        <path d="M10,10 L50,40 L90,10" />
                                    </svg>
                                    <span class="mini-label">抛物线 (Parabola)</span>
                                </div>
                                <div class="mini-chart-card">
                                    <svg class="mini-chart-svg" viewBox="0 0 100 50">
                                        <path d="M10,40 L30,40 L50,10 L70,10 L90,40" />
                                    </svg>
                                    <span class="mini-label">阶梯函数 (Step)</span>
                                </div>
                                <div class="mini-chart-card">
                                    <svg class="mini-chart-svg" viewBox="0 0 100 50">
                                        <path d="M10,25 L30,25 L50,40 L70,40 L90,25" />
                                    </svg>
                                    <span class="mini-label">S型曲线 (Sigmoid)</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <button class="btn-icon-only" onclick="toggleTheme()" id="themeBtn" title="切换明暗模式">
                <svg id="moonIcon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display:none;"><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"/></svg>
                <svg id="sunIcon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display:none;"><circle cx="12" cy="12" r="4"/><path d="M12 2v2"/><path d="M12 20v2"/><path d="m4.93 4.93 1.41 1.41"/><path d="m17.66 17.66 1.41 1.41"/><path d="M2 12h2"/><path d="M20 12h2"/><path d="m6.34 17.66-1.41 1.41"/><path d="m19.07 4.93-1.41 1.41"/></svg>
            </button>
        </div>
    </header>

    <div class="main-layout" id="mainLayout">
        <aside class="sidebar">
            <div class="panel-header">
                数据点输入 (Data Input)
                <button class="btn-lock" id="dragLockBtn" title="锁定/解锁图表拖动添加点功能">
                    <svg id="lockedIcon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round">
                        <rect x="3" y="11" width="18" height="11" rx="2" ry="2"/><path d="M7 11V7a5 5 0 0 1 10 0v4"/></svg>
                    <svg id="unlockedIcon" width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" style="display:none;">
                        <rect x="3" y="11" width="18" height="11" rx="2" ry="2"/><path d="M18 11V7a5 5 0 0 0-8.4-3.5"/></svg>
                    <span id="lockText">锁定拖动</span>
                </button>
            </div>
            <div class="panel-content">
                <div class="input-row">
                    <input type="number" id="xInput" placeholder="X 值" step="any">
                    <input type="number" id="yInput" placeholder="Y 值" step="any">
                    <button class="btn-primary" onclick="addPoint()">添加</button>
                </div>

                <div class="data-table-container">
                    <div id="pointsList">
                        </div>
                </div>

                <div class="btn-group">
                    <button class="btn-danger" onclick="clearAllData()">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6"/><path d="M10 11v6"/><path d="M14 11v6"/><path d="M15 2V4a2 2 0 0 0-2 2h-2a2 2 0 0 0-2-2V4a2 2 0 0 1 2-2h2a2 2 0 0 1 2 2v2"/></svg>
                        清空
                    </button>
                    <div class="file-input-wrapper">
                        <input type="file" accept=".txt" onchange="importTxt(event)">
                        <button class="btn-import">
                            <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><polyline points="17 8 12 3 7 8"/><line x1="12" y1="3" x2="12" y2="15"/></svg>
                            导入
                        </button>
                    </div>
                    <button class="btn-outline" onclick="exportTxt()">
                        <svg width="14" height="14" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2"><path d="M21 15v4a2 2 0 0 1-2 2H5a2 2 0 0 1-2-2v-4"/><polyline points="7 10 12 15 17 10"/><line x1="12" y1="15" x2="12" y2="3"/></svg>
                        导出
                    </button>
                </div>

                <div class="chart-controls">
                    <div class="control-item">
                        <div class="control-label">
                            <span>数据点大小 (Point Size)</span>
                            <span id="radiusVal">4px</span>
                        </div>
                        <input type="range" min="1" max="7" step="1" value="4" oninput="updateChartConfig(this.value, 'radius')">
                    </div>

                    <div class="control-item">
                        <div class="control-label">
                            <span>拟合曲线平滑度 (Smoothness)</span>
                            <span id="samplingVal">100 个点</span>
                        </div>
                        <input type="range" min="20" max="500" step="10" value="100" oninput="updateChartConfig(this.value, 'sampling')">
                    </div>

                    <div class="control-item">
                        <div class="control-label">
                            <span>X 轴自动填充范围 (Padding)</span>
                            <span id="xPaddingVal">10%</span>
                        </div>
                        <input type="range" min="0" max="30" step="5" value="10" oninput="updateChartConfig(this.value, 'xPadding')">
                    </div>
                </div>
            </div>
        </aside>

        <div class="resizer-vertical" id="verticalDragHandle">
            <div class="handle-vertical"></div>
        </div>

        <div class="content-area" id="contentArea">
            <div class="chart-wrapper" id="chartWrapper">
                <canvas id="fittingChart"></canvas>
                <div class="zoom-hint">使用滚轮缩放 | Shift+滚轮水平缩放</div>
            </div>
            
            <div class="resizer-horizontal" id="horizontalDragHandle">
                <div class="handle-horizontal"></div>
            </div>

            <div class="formulas-wrapper">
                <div class="panel-header">
                    拟合结果分析 (<span id="fitCount">0 个结果</span>)
                    <div style="font-size: 0.8rem; color: var(--text-secondary); font-weight: 400; font-style: italic;">
                        R² 越高，拟合优度越好
                    </div>
                </div>
                <div class="formulas-grid" id="formulaGrid">
                    <div style="text-align: center; padding: 20px; color: var(--text-secondary);">
                        等待数据点输入...
                    </div>
                </div>
            </div>
        </div>
    </div>
    
    <script>
        // =======================================================
        // 【核心数据和配置】
        // =======================================================
        let points = [];
        let editingIndex = -1;
        let chart = null;
        let chartConfig = {
            radius: 4,
            sampling: 100,
            xPadding: 0.1, // 10%
            theme: localStorage.getItem('theme') || (window.matchMedia('(prefers-color-scheme: dark)').matches ? 'dark' : 'light')
        };
        
        // 【新增/修改】拖动状态变量
        let isDragging = false;
        let draggingPoint = null;
        let dragEnabled = true; // 控制是否允许拖动添加点功能
        let shouldBlockClick = false; // 新增：用于区分拖动和点击
        let dragStartPos = {x: 0, y: 0}; // 新增：记录拖动起始位置
        const DRAG_TOLERANCE = 5; // 新增：拖动容差（像素）

        // 拟合模型类型枚举
        const FIT_TYPES = {
            LINEAR: 'linear',
            POLYNOMIAL: 'polynomial',
            EXPONENTIAL: 'exponential',
            LOGARITHMIC: 'logarithmic',
            POWER: 'power',
            SINE: 'sine',
            GAUSSIAN: 'gaussian',
            LORENTZIAN: 'lorentzian',
            HYPERBOLIC: 'hyperbolic',
            RATIONAL: 'rational',
            LOGISTIC: 'logistic',
            GOMPERTZ: 'gompertz',
            MICHAELIS_MENTEN: 'michaelis_menten' // 新增：米氏方程
        };

        // =======================================================
        // 【Levenberg-Marquardt 算法实现】
        // =======================================================

        /**
         * Levenberg-Marquardt 非线性最小二乘优化算法
         * @param {Function} modelFunc - 模型函数: (params, x) => y
         * @param {Array} data - 数据点: [[x1, y1], [x2, y2], ...]
         * @param {Array} initialParams - 初始参数估计
         * @param {Function} jacobianFunc - 雅可比矩阵函数: (params, x) => [dy/dp1, dy/dp2, ...]
         * @param {Object} options - 配置选项
         * @returns {Object} 优化结果
         */
        function levenbergMarquardt(modelFunc, data, initialParams, jacobianFunc, options = {}) {
            const {
                maxIterations = 100,
                tolerance = 1e-6,
                lambda0 = 0.001,
                lambdaFactor = 10
            } = options;

            let params = [...initialParams];
            let lambda = lambda0;
            let iteration = 0;
            let converged = false;
            
            // 计算残差
            function computeResiduals() {
                return data.map(([x, y]) => y - modelFunc(params, x));
            }
            
            // 计算当前误差
            function computeError(residuals) {
                return residuals.reduce((sum, r) => sum + r * r, 0) / residuals.length;
            }
            
            let residuals = computeResiduals();
            let currentError = computeError(residuals);
            let bestError = currentError;
            let bestParams = [...params];
            
            while (iteration < maxIterations && !converged) {
                // 计算雅可比矩阵
                const J = [];
                for (let i = 0; i < data.length; i++) {
                    const [x, y] = data[i];
                    J.push(jacobianFunc(params, x));
                }
                
                // 构建正规方程: (J^T J + λI) Δp = J^T r
                const n = params.length;
                const JTJ = Array(n).fill(0).map(() => Array(n).fill(0));
                const JTr = Array(n).fill(0);
                
                for (let i = 0; i < n; i++) {
                    for (let j = 0; j < n; j++) {
                        JTJ[i][j] = J.reduce((sum, row, idx) => sum + row[i] * row[j], 0);
                    }
                    JTr[i] = J.reduce((sum, row, idx) => sum + row[i] * residuals[idx], 0);
                }
                
                // 添加阻尼项
                const A = JTJ.map((row, i) => 
                    row.map((val, j) => val + (i === j ? lambda * val : 0))
                );
                
                // 解线性方程组 (使用简单的高斯消元法)
                const delta = solveLinearSystem(A, JTr);
                
                // 尝试新参数
                const newParams = params.map((p, i) => p + delta[i]);
                const newResiduals = data.map(([x, y]) => y - modelFunc(newParams, x));
                const newError = computeError(newResiduals);
                
                if (newError < currentError) {
                    // 接受新参数
                    params = newParams;
                    residuals = newResiduals;
                    currentError = newError;
                    lambda /= lambdaFactor;
                    
                    if (currentError < bestError) {
                        bestError = currentError;
                        bestParams = [...params];
                    }
                    
                    // 检查收敛
                    if (Math.abs(newError - currentError) < tolerance || 
                        delta.reduce((max, d) => Math.max(max, Math.abs(d)), 0) < tolerance) {
                        converged = true;
                    }
                } else {
                    // 拒绝新参数，增加阻尼
                    lambda *= lambdaFactor;
                }
                
                iteration++;
            }
            
            return {
                params: bestParams,
                error: bestError,
                iterations: iteration,
                converged: converged
            };
        }

        /**
         * 解线性方程组 Ax = b (使用高斯消元法)
         */
        function solveLinearSystem(A, b) {
            const n = A.length;
            const Ab = A.map((row, i) => [...row, b[i]]);
            
            // 前向消元
            for (let i = 0; i < n; i++) {
                // 找主元
                let maxRow = i;
                for (let j = i + 1; j < n; j++) {
                    if (Math.abs(Ab[j][i]) > Math.abs(Ab[maxRow][i])) {
                        maxRow = j;
                    }
                }
                
                // 交换行
                [Ab[i], Ab[maxRow]] = [Ab[maxRow], Ab[i]];
                
                // 消元
                for (let j = i + 1; j < n; j++) {
                    const factor = Ab[j][i] / Ab[i][i];
                    for (let k = i; k <= n; k++) {
                        Ab[j][k] -= factor * Ab[i][k];
                    }
                }
            }
            
            // 回代
            const x = Array(n).fill(0);
            for (let i = n - 1; i >= 0; i--) {
                x[i] = Ab[i][n];
                for (let j = i + 1; j < n; j++) {
                    x[i] -= Ab[i][j] * x[j];
                }
                x[i] /= Ab[i][i];
            }
            
            return x;
        }

        // =======================================================
        // 【LM算法模型定义】
        // =======================================================

        // 高斯模型函数和雅可比矩阵
        function gaussianModel(params, x) {
            const [A, mu, sigma] = params;
            return A * Math.exp(-Math.pow(x - mu, 2) / (2 * sigma * sigma));
        }

        function gaussianJacobian(params, x) {
            const [A, mu, sigma] = params;
            const expVal = Math.exp(-Math.pow(x - mu, 2) / (2 * sigma * sigma));
            const dA = expVal;
            const dMu = A * expVal * (x - mu) / (sigma * sigma);
            const dSigma = A * expVal * Math.pow(x - mu, 2) / (sigma * sigma * sigma);
            return [dA, dMu, dSigma];
        }

        // 洛伦兹模型函数和雅可比矩阵
        function lorentzianModel(params, x) {
            const [A, mu, gamma] = params;
            return A / (1 + Math.pow((x - mu) / gamma, 2));
        }

        function lorentzianJacobian(params, x) {
            const [A, mu, gamma] = params;
            const denom = 1 + Math.pow((x - mu) / gamma, 2);
            const dA = 1 / denom;
            const dMu = (2 * A * (x - mu)) / (Math.pow(gamma, 2) * Math.pow(denom, 2));
            const dGamma = (2 * A * Math.pow(x - mu, 2)) / (Math.pow(gamma, 3) * Math.pow(denom, 2));
            return [dA, dMu, dGamma];
        }

        // 米氏方程模型函数和雅可比矩阵
        function michaelisMentenModel(params, x) {
            const [Vmax, Km] = params;
            return (Vmax * x) / (Km + x);
        }

        function michaelisMentenJacobian(params, x) {
            const [Vmax, Km] = params;
            const dVmax = x / (Km + x);
            const dKm = (-Vmax * x) / Math.pow(Km + x, 2);
            return [dVmax, dKm];
        }

        // =======================================================
        // 【初始化与主题】
        // =======================================================

        function initChart() {
            const ctx = document.getElementById('fittingChart').getContext('2d');
            const scatterData = points.map(p => ({x: p[0], y: p[1]}));
            const fitPoints = []; // 初始空

            // Chart.js 颜色配置函数，用于动态适应主题
            const getChartColor = (cssVar) => {
                const computed = getComputedStyle(document.documentElement).getPropertyValue(cssVar);
                return computed ? computed.trim() : cssVar;
            };
            
            chart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [{
                        label: '数据点 (Data Points)',
                        data: scatterData,
                        backgroundColor: 'red', // <--- FIX 1: 数据点颜色改为红色
                        borderColor: 'red',     // <--- FIX 1: 数据点边框颜色改为红色
                        pointRadius: chartConfig.radius,
                        order: 1 // 数据点在上层
                    }, {
                        label: '拟合曲线 (Fit Curve)',
                        data: fitPoints,
                        type: 'line',
                        fill: false,
                        borderColor: getChartColor('--primary-color'),
                        borderWidth: 2,
                        pointBackgroundColor: 'transparent',
                        pointBorderColor: 'transparent',
                        pointRadius: 0,
                        order: 2 // 拟合曲线在下层
                    }]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: {
                        duration: 400
                    },
                    scales: {
                        x: {
                            type: 'linear',
                            position: 'bottom',
                            title: {
                                display: true,
                                text: 'X 轴 (自变量)',
                                color: (ctx) => chartConfig.theme === 'dark' ? getChartColor('--chart-text') : getChartColor('--text-secondary')
                            },
                            grid: {
                                color: (ctx) => getChartColor('--chart-grid')
                            },
                            ticks: {
                                color: (ctx) => getChartColor('--chart-text')
                            }
                        },
                        y: {
                            type: 'linear',
                            title: {
                                display: true,
                                text: 'Y 轴 (因变量)',
                                color: (ctx) => chartConfig.theme === 'dark' ? getChartColor('--chart-text') : getChartColor('--text-secondary')
                            },
                            grid: {
                                color: (ctx) => getChartColor('--chart-grid')
                            },
                            ticks: {
                                color: (ctx) => getChartColor('--chart-text')
                            }
                        }
                    },
                    plugins: {
                        legend: {
                            display: true,
                            labels: {
                                color: (ctx) => getChartColor('--text-primary')
                            }
                        },
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    let label = context.dataset.label || '';
                                    if (label) {
                                        label += ': ';
                                    }
                                    if (context.parsed.x !== null) {
                                        label += `(X: ${context.parsed.x.toFixed(4)}, Y: ${context.parsed.y.toFixed(4)})`;
                                    }
                                    return label;
                                }
                            }
                        }
                    },
                    interaction: {
                        mode: 'nearest',
                        intersect: false
                    }
                }
            });

            // 初始化滚轮缩放
            initWheelZoom();
        }

        function updateChart(fitPoints, r2) {
            if (!chart) return;

            const scatterData = points.map(p => ({x: p[0], y: p[1]}));

            // 1. 更新数据点
            chart.data.datasets[0].data = scatterData;

            // 2. 更新拟合曲线
            if (fitPoints) {
                chart.data.datasets[1].data = fitPoints;
                chart.data.datasets[1].label = `拟合曲线 (Fit Curve, R²:${r2.toFixed(4)})`;
            } else {
                chart.data.datasets[1].data = [];
                chart.data.datasets[1].label = '拟合曲线 (Fit Curve)';
            }

            // 3. 自动调整X轴范围（包含Padding）
            if (points.length > 0) {
                const xValues = points.map(p => p[0]);
                const xMin = Math.min(...xValues);
                const xMax = Math.max(...xValues);
                const xRange = xMax - xMin;
                
                // 确保xRange不为零
                const padding = xRange === 0 ? 1 : xRange * chartConfig.xPadding;

                chart.options.scales.x.min = xMin - padding;
                chart.options.scales.x.max = xMax + padding;
            } else {
                 // 清空数据时重置为默认值
                chart.options.scales.x.min = undefined;
                chart.options.scales.x.max = undefined;
            }

            chart.update();
        }

        function updateChartTheme() {
            if (!chart) return;
            // 重新获取主题相关的颜色
            const getChartColor = (cssVar) => {
                const computed = getComputedStyle(document.documentElement).getPropertyValue(cssVar);
                return computed ? computed.trim() : cssVar;
            };

            const primaryColor = getChartColor('--primary-color');
            const textPrimary = getChartColor('--text-primary');
            const textSecondary = getChartColor('--text-secondary');
            const chartGrid = getChartColor('--chart-grid');
            const chartText = getChartColor('--chart-text');

            // 更新刻度和网格颜色
            chart.options.scales.x.title.color = chartConfig.theme === 'dark' ? chartText : textSecondary;
            chart.options.scales.x.grid.color = chartGrid;
            chart.options.scales.x.ticks.color = chartText;
            
            chart.options.scales.y.title.color = chartConfig.theme === 'dark' ? chartText : textSecondary;
            chart.options.scales.y.grid.color = chartGrid;
            chart.options.scales.y.ticks.color = chartText;

            // 更新拟合曲线颜色（如果需要）
            chart.data.datasets[1].borderColor = primaryColor;

            // 更新图例颜色
            chart.options.plugins.legend.labels.color = textPrimary;

            chart.update('none');
        }

        function toggleTheme() {
            const currentTheme = chartConfig.theme;
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            document.documentElement.setAttribute('data-theme', newTheme);
            chartConfig.theme = newTheme;
            localStorage.setItem('theme', newTheme);
            updateThemeIcons(newTheme);
            updateChartTheme();
        }

        function updateThemeIcons(theme) {
            const sunIcon = document.getElementById('sunIcon');
            const moonIcon = document.getElementById('moonIcon');
            if (theme === 'dark') {
                sunIcon.style.display = 'block';
                moonIcon.style.display = 'none';
            } else {
                sunIcon.style.display = 'none';
                moonIcon.style.display = 'block';
            }
        }

        function applyInitialTheme() {
            document.documentElement.setAttribute('data-theme', chartConfig.theme);
            updateThemeIcons(chartConfig.theme);
        }

        function updateChartConfig(value, type) {
            if (type === 'radius') {
                chartConfig.radius = parseInt(value);
                document.getElementById('radiusVal').textContent = `${value}px`;
                if (chart && chart.data.datasets[0]) {
                    chart.data.datasets[0].pointRadius = chartConfig.radius;
                    chart.update('none');
                }
            } else if (type === 'sampling') {
                chartConfig.sampling = parseInt(value);
                document.getElementById('samplingVal').textContent = `${value} 个点`;
                calculateAllFits(); // 重新计算拟合点
            } else if (type === 'xPadding') {
                chartConfig.xPadding = parseInt(value) / 100;
                document.getElementById('xPaddingVal').textContent = `${value}%`;
                calculateAllFits(); // 重新计算以更新轴范围
            }
        }

        // =======================================================
        // 【数据点列表与CRUD操作】
        // =======================================================

        function updatePointsList() {
            const list = document.getElementById('pointsList');
            list.innerHTML = '';

            if (points.length === 0) {
                list.innerHTML = `<div style="text-align: center; padding: 20px; color: var(--text-secondary);">暂无数据点</div>`;
                return;
            }

            points.forEach((point, index) => {
                const row = document.createElement('div');
                row.className = `data-row ${index === editingIndex ? 'editing' : ''}`;
                row.setAttribute('data-index', index);

                if (index === editingIndex) {
                    row.innerHTML = `
                        <div>${index + 1}.</div>
                        <input type="number" id="editX_${index}" class="edit-input" value="${point[0]}" step="any">
                        <input type="number" id="editY_${index}" class="edit-input" value="${point[1]}" step="any">
                        <div class="edit-buttons">
                            <button class="btn-primary edit-btn" onclick="saveEdit(${index})" title="保存">
                                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><path d="M20 6 9 17l-5-5"/></svg>
                            </button>
                            <button class="btn-danger edit-btn" onclick="cancelEdit(${index})" title="取消">
                                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="3" stroke-linecap="round" stroke-linejoin="round"><line x1="18" y1="6" x2="6" y2="18"/><line x1="6" y1="6" x2="18" y2="18"/></svg>
                            </button>
                        </div>
                    `;
                    row.onkeydown = (e) => {
                        if (e.key === 'Enter') saveEdit(index);
                        if (e.key === 'Escape') cancelEdit(index);
                    };
                } else {
                    row.innerHTML = `
                        <div style="width: 15px; flex-shrink: 0;">${index + 1}.</div>
                        <div style="flex-grow: 1; text-align: right;">X: ${point[0].toFixed(4)}</div>
                        <div style="flex-grow: 1; text-align: right;">Y: ${point[1].toFixed(4)}</div>
                        <div class="edit-buttons" style="width: 36px; flex-shrink: 0;">
                            <button class="btn-ghost edit-btn" onclick="editPoint(${index})" title="编辑">
                                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M17 3a2.85 2.85 0 0 1 4 4L7.5 20.5 2 22l1.5-5.5Z"/></svg>
                            </button>
                            <button class="btn-ghost edit-btn" onclick="deletePoint(${index})" title="删除">
                                <svg width="12" height="12" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M10 12v.01"/><path d="M14 12v.01"/><path d="M2 12s3-7 10-7 10 7 10 7-3 7-10 7-10-7-10-7Z"/></svg>
                            </button>
                        </div>
                    `;
                    row.onclick = (e) => {
                        // 阻止点击编辑/删除按钮时触发
                        if (e.target.tagName !== 'BUTTON' && e.target.closest('button') === null) {
                            editPoint(index);
                        }
                    };
                }
                list.appendChild(row);
            });
        }

        function addPoint(xVal = null, yVal = null) {
            const xInput = document.getElementById('xInput');
            const yInput = document.getElementById('yInput');

            if (xVal === null) xVal = parseFloat(xInput.value);
            if (yVal === null) yVal = parseFloat(yInput.value);

            if (!isNaN(xVal) && !isNaN(yVal)) {
                // 限制精度，避免浮点数过长
                const newX = parseFloat(xVal.toFixed(4));
                const newY = parseFloat(yVal.toFixed(4));

                points.push([newX, newY]);
                points.sort((a, b) => a[0] - b[0]);
                
                xInput.value = '';
                yInput.value = '';
                xInput.focus();

                updatePointsList();
                calculateAllFits();
            }
        }

        function deletePoint(index) {
            points.splice(index, 1);
            editingIndex = -1;
            points.sort((a, b) => a[0] - b[0]);
            updatePointsList();
            calculateAllFits();
        }
        
        function clearAllData() {
            if (points.length > 0 && confirm("确定清空所有数据点吗？此操作不可撤销。")) {
                points = [];
                editingIndex = -1;
                updatePointsList();
                calculateAllFits();
            } else if (points.length === 0) {
                 alert("当前列表已为空。");
            }
        }

        // 数据点编辑功能
        function editPoint(index) {
            if (editingIndex !== -1) {
                cancelEdit(editingIndex);
            }
            editingIndex = index;
            updatePointsList();
            
            // 焦点移动到第一个输入框
            setTimeout(() => {
                const xInput = document.getElementById(`editX_${index}`);
                if (xInput) xInput.focus();
            }, 0);
        }

        function saveEdit(index) {
            const xInput = document.getElementById(`editX_${index}`);
            const yInput = document.getElementById(`editY_${index}`);
            const newX = parseFloat(xInput.value);
            const newY = parseFloat(yInput.value);

            if (!isNaN(newX) && !isNaN(newY)) {
                points[index] = [parseFloat(newX.toFixed(4)), parseFloat(newY.toFixed(4))];
                editingIndex = -1;
                points.sort((a, b) => a[0] - b[0]);
                updatePointsList();
                calculateAllFits();
            } else {
                alert("X值或Y值无效，请重新输入。");
            }
        }

        function cancelEdit(index) {
            editingIndex = -1;
            updatePointsList();
        }
        
        // =======================================================
        // 【拖动交互】
        // =======================================================
        
        function initDragHandling() {
            const canvas = document.getElementById('fittingChart');
            if (!canvas) return;

            canvas.addEventListener('mousedown', handleMouseDown);
            canvas.addEventListener('mousemove', handleMouseMove);
            canvas.addEventListener('mouseup', handleMouseUp);
            canvas.addEventListener('click', handleCanvasClick); // 监听点击事件
            
            // 初始光标
            canvas.style.cursor = dragEnabled ? 'grab' : 'default';
        }
        
        // 【修改】处理鼠标按下
        function handleMouseDown(e) {
            if (e.button !== 0 || !chart) return; // 只处理左键
            const rect = chart.canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;

            // 【新增】记录拖动起始位置并重置点击阻断标记
            dragStartPos = {x: e.clientX, y: e.clientY};
            shouldBlockClick = false; 

            draggingPoint = findClosestPoint(x, y); // 尝试找到最近的点

            if (draggingPoint) {
                isDragging = true; // 开始拖动
                chart.options.animation = { duration: 0 }; // 拖动时禁用动画
                document.body.style.cursor = 'grabbing';
                e.preventDefault();
            }
        }
        
        // 【修改】处理鼠标移动
        function handleMouseMove(e) {
            if (!isDragging || !draggingPoint) return;
            
            // 【新增】检查是否有明显移动，若有则标记为拖动，以阻止后续的click事件
            const movedX = Math.abs(e.clientX - dragStartPos.x);
            const movedY = Math.abs(e.clientY - dragStartPos.y);
            if (movedX > DRAG_TOLERANCE || movedY > DRAG_TOLERANCE) {
                 shouldBlockClick = true; 
            }

            const rect = chart.canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            const dataX = chart.scales.x.getValueForPixel(x);
            const dataY = chart.scales.y.getValueForPixel(y);

            // 限制拖动范围在图表内，但 Chart.js 默认会处理
            points[draggingPoint.index] = [dataX, dataY];
            updateScatterPointsOnly();
            e.preventDefault();
        }

        // 【修改】处理鼠标抬起
        function handleMouseUp(e) {
            if (isDragging) {
                isDragging = false;
                
                document.body.style.cursor = dragEnabled ? 'grab' : 'default';
                if (chart) {
                    chart.options.animation = { duration: 400 };
                }
                
                // 【修改】只在发生拖动（shouldBlockClick为true）时才重新计算和更新列表
                if (shouldBlockClick) { 
                    points.sort((a, b) => a[0] - b[0]);
                    updatePointsList();
                    calculateAllFits();
                }
                
                draggingPoint = null;
            }
        }
        
        // 【新增】处理点击事件 (FIX 2)
        function handleCanvasClick(e) {
            // 检查是否是拖动操作后的click事件
            if (shouldBlockClick) {
                shouldBlockClick = false; // 重置标记
                return; // 阻止新点创建
            }

            // 只有在拖动添加点功能开启时才添加点 (isDragging此时应为false)
            if (!dragEnabled) return; 

            const canvas = chart.canvas;
            const rect = canvas.getBoundingClientRect();
            const x = e.clientX - rect.left;
            const y = e.clientY - rect.top;
            
            // 检查是否点击到了一个已有点（避免在双击或快速点击时重复添加）
            if (findClosestPoint(x, y)) {
                 return; // 如果点击到已有点，则不新增点
            }

            const xVal = chart.scales.x.getValueForPixel(x);
            const yVal = chart.scales.y.getValueForPixel(y);
            
            if (xVal !== undefined && yVal !== undefined) {
                // 限制精度，避免浮点数过长
                const newX = parseFloat(xVal.toFixed(4));
                const newY = parseFloat(yVal.toFixed(4));
                
                points.push([newX, newY]);
                points.sort((a, b) => a[0] - b[0]);
                updatePointsList();
                calculateAllFits();
            }
        }
        

        // 用于判断是否点击到数据点的函数
        function findClosestPoint(x, y) {
            if (!chart) return null;
            const tolerance = chartConfig.radius + 8; // 增加容差范围

            for (let i = 0; i < points.length; i++) {
                const point = points[i];
                const pixelX = chart.scales.x.getPixelForValue(point[0]);
                const pixelY = chart.scales.y.getPixelForValue(point[1]);
                const distance = Math.sqrt(Math.pow(x - pixelX, 2) + Math.pow(y - pixelY, 2));
                
                if (distance <= tolerance) {
                    return { index: i, point: point };
                }
            }
            return null;
        }

        // 仅更新散点图数据，不触发完整更新和拟合计算（用于拖动时的平滑过渡）
        function updateScatterPointsOnly() {
            if (!chart) return;
            const scatterData = points.map(p => ({x: p[0], y: p[1]}));
            chart.data.datasets[0].data = scatterData;
            chart.update('none'); // 使用'none'以避免动画
        }

        // =======================================================
        // 【缩放与窗口调整】
        // =======================================================

        function initWheelZoom() {
            const canvas = document.getElementById('fittingChart');
            if (!canvas) return;

            canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                if (!chart || points.length === 0) return; 

                const rect = canvas.getBoundingClientRect();
                const x = e.clientX - rect.left;
                const y = e.clientY - rect.top;
                const xScale = chart.scales.x;
                const yScale = chart.scales.y;

                // 获取鼠标位置对应的数据值
                const mouseX = xScale.getValueForPixel(x);
                const mouseY = yScale.getValueForPixel(y);

                if (mouseX === undefined || mouseY === undefined) return;

                // 确定缩放因子
                const zoomIntensity = 0.1;
                const zoomFactor = e.deltaY < 0 ? 1 / (1 - zoomIntensity) : (1 - zoomIntensity); // 滚轮向下 deltaY > 0 -> zoomFactor < 1 (缩小)
                
                // 检查是否按下了Shift键（水平缩放）
                const isHorizontalZoom = e.shiftKey;

                if (isHorizontalZoom) {
                    // 仅水平缩放
                    xScale.min = mouseX - (mouseX - xScale.min) * zoomFactor;
                    xScale.max = mouseX + (xScale.max - mouseX) * zoomFactor;
                } else {
                    // 正常缩放（同时缩放X和Y轴）
                    xScale.min = mouseX - (mouseX - xScale.min) * zoomFactor;
                    xScale.max = mouseX + (xScale.max - mouseX) * zoomFactor;
                    yScale.min = mouseY - (mouseY - yScale.min) * zoomFactor;
                    yScale.max = mouseY + (yScale.max - mouseY) * zoomFactor;
                }
                
                chart.update('none');
            }, { passive: false });
        }

        function initHorizontalResizer() {
            const resizer = document.getElementById('horizontalDragHandle');
            const chartWrapper = document.getElementById('chartWrapper');
            const contentArea = document.getElementById('contentArea');
            const minChartHeight = 150;
            let isResizing = false;
            let startY, startHeight;

            resizer.addEventListener('mousedown', (e) => {
                isResizing = true;
                startY = e.clientY;
                startHeight = chartWrapper.offsetHeight;
                document.body.style.cursor = 'row-resize';
                document.body.style.userSelect = 'none';
                if(chart) chart.options.events = []; // 禁用图表事件
            });

            document.addEventListener('mousemove', (e) => {
                if (!isResizing) return;
                const deltaY = e.clientY - startY;
                let newHeight = startHeight + deltaY;
                const maxChartHeight = contentArea.offsetHeight - resizer.offsetHeight - minChartHeight;
                
                newHeight = Math.max(minChartHeight, Math.min(newHeight, maxChartHeight));
                
                chartWrapper.style.flex = `0 0 ${newHeight}px`;
                if(chart) chart.resize(); // 调整图表大小
            });

            document.addEventListener('mouseup', () => {
                if (isResizing) {
                    isResizing = false;
                    document.body.style.cursor = '';
                    document.body.style.userSelect = '';
                    if(chart) {
                        chart.options.events = ['mousemove', 'mouseout', 'click', 'touchstart', 'touchmove']; // 恢复图表事件
                        chart.update('none');
                    }
                }
            });
        }

        function initVerticalResizer() {
            const resizer = document.getElementById('verticalDragHandle');
            const sidebar = document.querySelector('.sidebar');
            const mainLayout = document.getElementById('mainLayout');
            const minSidebarWidth = 250;
            const maxSidebarWidth = 500;
            let isResizing = false;
            let startX, startWidth;

            resizer.addEventListener('mousedown', (e) => {
                isResizing = true;
                startX = e.clientX;
                startWidth = sidebar.offsetWidth;
                document.body.style.cursor = 'col-resize';
                document.body.style.userSelect = 'none';
            });

            document.addEventListener('mousemove', (e) => {
                if (!isResizing) return;
                const deltaX = e.clientX - startX;
                let newWidth = startWidth + deltaX;

                newWidth = Math.max(minSidebarWidth, Math.min(newWidth, maxSidebarWidth));
                
                mainLayout.style.gridTemplateColumns = `${newWidth}px 14px 1fr`;
                if(chart) chart.resize(); // 调整图表大小
            });

            document.addEventListener('mouseup', () => {
                if (isResizing) {
                    isResizing = false;
                    document.body.style.cursor = '';
                    document.body.style.userSelect = '';
                    document.documentElement.style.setProperty('--sidebar-width', `${sidebar.offsetWidth}px`);
                }
            });
        }


        // =======================================================
        // 【数据导入/导出】
        // =======================================================

        function setupInputs() {
             // 允许在X输入框按Enter时将焦点移到Y
            const xInput = document.getElementById('xInput');
            const yInput = document.getElementById('yInput');
            const addBtn = document.querySelector('.input-row .btn-primary');

            if (xInput) {
                xInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        if (xInput.value && !yInput.value) {
                             yInput.focus();
                        } else {
                            addPoint();
                        }
                    }
                });
            }

             // 允许在Y输入框按Enter时添加点
            if (yInput) {
                 yInput.addEventListener('keydown', (e) => {
                    if (e.key === 'Enter') {
                        e.preventDefault();
                        addPoint();
                    }
                });
            }
        }

        function importTxt(event) {
            const file = event.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (e) => {
                const content = e.target.result.trim();
                const lines = content.split(/\r?\n/).filter(line => line.trim() !== '');
                
                // 清空旧数据
                points = [];
                let addedCount = 0;

                // 尝试解析为一行一个点 (x,y) 的格式
                for (const line of lines) {
                    // 允许逗号、空格或制表符作为分隔符
                    const parts = line.trim().split(/[\s,]+/).filter(p => p !== '');
                    if (parts.length >= 2) {
                        const x = parseFloat(parts[0]);
                        const y = parseFloat(parts[1]);
                        if (!isNaN(x) && !isNaN(y)) {
                            points.push([parseFloat(x.toFixed(4)), parseFloat(y.toFixed(4))]);
                            addedCount++;
                        }
                    }
                }
                
                if (addedCount > 0) {
                    points.sort((a, b) => a[0] - b[0]);
                    updatePointsList();
                    calculateAllFits();
                    console.log(`已成功导入 ${addedCount} 个数据点`);
                } else {
                    alert("未在文件中找到有效的格式数据 (每行 x,y 或 x y)");
                }

                event.target.value = ''; // 清空文件输入，以便再次选择相同文件
            };
            reader.readAsText(file);
        }

        function exportTxt() {
            if (points.length === 0) {
                alert("无数据可导出");
                return;
            }
            const dataText = points.map(p => `${p[0]},${p[1]}`).join('\n');
            const blob = new Blob([dataText], {type: 'text/plain'});
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = 'fitting_data.txt';
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        }

        // =======================================================
        // 【核心修正区】 极致优美化功能和完整拟合模型
        // =======================================================
        
        // R² 严谨性计算函数
        function calculateR2FromPrediction(data, predictFunc) {
            if (data.length < 2) return 0;
            
            const yValues = data.map(p => p[1]);
            const yMean = yValues.reduce((sum, y) => sum + y, 0) / yValues.length;
            
            let ssRes = 0; // 残差平方和 (Sum of Squares of Residuals)
            let ssTot = 0; // 总平方和 (Total Sum of Squares)

            for (const point of data) {
                const x = point[0];
                const y = point[1];
                const yPred = predictFunc(x);
                
                ssRes += Math.pow(y - yPred, 2);
                ssTot += Math.pow(y - yMean, 2);
            }

            // 如果 ssTot 接近 0 (所有Y值都相同)，返回 1，因为拟合是完美的
            if (ssTot < 1e-10) return 1; 

            return 1 - (ssRes / ssTot);
        }
        
        // 生成拟合曲线点的函数
        function generateFitPoints(data, predictFunc) {
            if (data.length < 1) return [];

            const xValues = data.map(p => p[0]);
            const xMin = Math.min(...xValues);
            const xMax = Math.max(...xValues);
            const xRange = xMax - xMin;

            // 包含X轴填充
            const padding = xRange * chartConfig.xPadding;
            const startX = xMin - padding;
            const endX = xMax + padding;
            const step = (endX - startX) / chartConfig.sampling;

            const fitPoints = [];
            for (let i = 0; i <= chartConfig.sampling; i++) {
                const x = startX + i * step;
                try {
                    const y = predictFunc(x);
                    // 避免无穷大或NaN
                    if (isFinite(y)) {
                         fitPoints.push({x, y});
                    }
                } catch (e) {
                    // 忽略计算错误
                }
            }
            return fitPoints;
        }

        // 极致优美化系数函数
        function beautifyCoefficient(val, idx, operations) {
            // 0. 检查是否为0
            if (Math.abs(val) < 1e-10) return 0; 
            
            // 1. 检查是否为简单分数 (1/3, 1/4, 2/3, 3/4...)
            const fractions = [1/2, 1/3, 2/3, 1/4, 3/4, 1/5, 2/5, 3/5, 4/5, 1/6, 5/6, Math.PI, Math.E];
            let closestFraction = 0;
            let minDiff = Infinity;

            for (const f of fractions) {
                const diff = Math.abs(Math.abs(val) - f);
                if (diff < minDiff) {
                    minDiff = diff;
                    closestFraction = f;
                }
            }
            
            // 容差：小于绝对值中较大者的5%
            if (minDiff < 0.05 * Math.max(1, Math.abs(val))) {
                const sign = val < 0 ? -1 : 1;
                const niceVal = sign * closestFraction;
                operations.push(`系数[${idx}] ${val.toFixed(4)} → 规整为 ${niceVal}`);
                return niceVal;
            }

            // 2. 检查是否为整数
            const rounded = Math.round(val);
            // 容差：小于自身/绝对值中较大者的5%
            if (Math.abs(val - rounded) < 0.05 * Math.max(1, Math.abs(val))) {
                 if (Math.abs(val - rounded) > 1e-10) {
                     operations.push(`系数[${idx}] ${val.toFixed(4)} → 取整为 ${rounded}`);
                 }
                return rounded;
            }

            // 3. 检查是否为简单小数 (0.5, 1.5, 2.5...)
            const d2 = val * 2;
            const r2 = Math.round(d2);
            if (Math.abs(d2 - r2) < 0.05) {
                const niceVal = r2 / 2;
                 operations.push(`系数[${idx}] ${val.toFixed(4)} → 规整为 ${niceVal}`);
                return niceVal;
            }

            // 4. 检查是否为简单倍数 (例如 3.012 ≈ 3.0)
            for (let i = 2; i <= 10; i++) {
                const multiple = val / i;
                const roundedMultiple = Math.round(multiple);
                if (Math.abs(multiple - roundedMultiple) < 0.05) {
                    const niceVal = roundedMultiple * i;
                    if (Math.abs(val - niceVal) > 1e-10) {
                         operations.push(`系数[${idx}] ${val.toFixed(4)} → 规整为 ${niceVal}`);
                    }
                    return niceVal;
                }
            }

            // 5. 否则，保留4位小数
            return parseFloat(val.toFixed(4));
        }
        
        // 极致优美化公式函数
        function performBeautification(fitName, coefficients, rawTemplate, fitType) {
            const operations = [];
            const niceCoeffs = coefficients.map((c, idx) => beautifyCoefficient(c, idx, operations));
            let displayFormula = '';
            let fitCategory = '';
            let fitSubtype = '';
            let r2Optimized = 0;
            let predictFunc;

            // 根据拟合类型构建公式和预测函数
            switch (fitType) {
                case FIT_TYPES.LINEAR: // y = a + bx
                    const a_lin = niceCoeffs[0];
                    const b_lin = niceCoeffs[1];
                    displayFormula = `y = ${b_lin === 0 ? '' : b_lin + 'x'}${b_lin !== 0 && a_lin > 0 ? ' + ' : ''}${a_lin === 0 ? (b_lin === 0 ? '0' : '') : a_lin}`;
                    displayFormula = displayFormula.replace(/\+ -/g, '- ').replace(/1x/g, 'x').replace(/-1x/g, '-x');
                    fitCategory = '代数模型 (Algebraic)';
                    fitSubtype = '基本趋势分析';
                    predictFunc = x => a_lin + b_lin * x;
                    break;
                
                case FIT_TYPES.POLYNOMIAL: // y = c₀ + c₁x + c₂x² + ...
                    let polyTerms = [];
                    // c₀
                    if (Math.abs(niceCoeffs[0]) > 1e-10) polyTerms.push(niceCoeffs[0]);
                    // c₁x
                    if (Math.abs(niceCoeffs[1]) > 1e-10) polyTerms.push((Math.abs(niceCoeffs[1]) === 1 ? (niceCoeffs[1] > 0 ? 'x' : '-x') : niceCoeffs[1] + 'x'));
                    // c₂x² + ...
                    for (let i = 2; i < niceCoeffs.length; i++) {
                        if (Math.abs(niceCoeffs[i]) > 1e-10) {
                            let coeff = niceCoeffs[i];
                            let term = (Math.abs(coeff) === 1 ? (coeff > 0 ? '' : '-') : coeff) + 'x^' + i;
                            polyTerms.push(term);
                        }
                    }

                    if (polyTerms.length === 0) {
                         displayFormula = 'y = 0';
                    } else {
                        // 构建带符号的公式
                        displayFormula = polyTerms.map((term, index) => {
                            if (index === 0) return term;
                            if (typeof term === 'number') {
                                return term > 0 ? ` + ${term}` : ` - ${-term}`;
                            } else {
                                const sign = term.startsWith('-') ? ' - ' : ' + ';
                                return sign + (sign === ' + ' ? term : term.slice(1));
                            }
                        }).join('');
                        
                        // 修正系数前的符号
                        displayFormula = displayFormula.replace(/\+ -/g, '- ');

                        // 将所有 ' + ' 替换为正常的加号，除了第一个系数前的符号
                        const parts = displayFormula.split(' ');
                        displayFormula = parts.map((part, index) => {
                            if (index > 0 && part === '+') return ''; // 移除多余的加号
                            if (index === 0 && part === '+') return part.slice(1); // 移除开头的正号
                            return part;
                        }).join(' ').trim();
                        
                        // 尝试识别顶点式 y = a(x-p)² + q (针对二次多项式)
                        if (coefficients.length === 3) {
                             const a = niceCoeffs[2];
                             const b = niceCoeffs[1];
                             const c = niceCoeffs[0];
                             const p_val = -b / (2 * a);
                             const q = c - a * p_val * p_val;
                             const c_val = a * p_val * p_val + q;

                             // 检查是否接近顶点式展开
                             if (Math.abs(c - c_val) < 0.05 * Math.max(1, Math.abs(c))) {
                                 const p = parseFloat(p_val.toFixed(4));
                                 const q_nice = parseFloat(q.toFixed(4));
                                 displayFormula = `y = ${a} (x ${p >= 0 ? '- ' + p : '+ ' + (-p)})² ${q_nice >= 0 ? '+ ' + q_nice : q_nice}`;
                                 operations.push(`识别为顶点式 y = a(x-p)² + q, p ≈ ${p_val.toFixed(3)}`);
                             }
                        }
                    }
                    
                    fitCategory = '代数模型 (Algebraic)';
                    fitSubtype = `${coefficients.length - 1} 阶多项式`;

                    predictFunc = x => niceCoeffs.reduce((sum, c, i) => sum + c * Math.pow(x, i), 0);
                    break;
                
                case FIT_TYPES.EXPONENTIAL: // y = aeᵇˣ
                    const a_exp = niceCoeffs[0];
                    const b_exp = niceCoeffs[1];
                    displayFormula = `y = ${a_exp}e${b_exp === 1 ? 'ˣ' : (b_exp === -1 ? '⁻ˣ' : `⁽${b_exp}ˣ⁾`)}`;
                    fitCategory = '超越模型 (Transcendental)';
                    fitSubtype = '基本增长/衰减';
                    predictFunc = x => a_exp * Math.exp(b_exp * x);
                    break;

                case FIT_TYPES.LOGARITHMIC: // y = a + b ln(x)
                    const a_log = niceCoeffs[0];
                    const b_log = niceCoeffs[1];
                    displayFormula = `y = ${a_log}${b_log > 0 ? ' + ' : ''}${b_log === 0 ? '' : b_log + ' ln(x)'}`;
                    displayFormula = displayFormula.replace(/\+ -/g, '- ');
                    fitCategory = '超越模型 (Transcendental)';
                    fitSubtype = '对数饱和/衰减';
                    predictFunc = x => a_log + b_log * Math.log(x);
                    break;

                case FIT_TYPES.POWER: // y = axᵇ
                    const a_pow = niceCoeffs[0];
                    const b_pow = niceCoeffs[1];
                    displayFormula = `y = ${a_pow === 1 ? '' : a_pow}x${b_pow === 1 ? '' : (b_pow === -1 ? '⁻¹' : '⁽' + b_pow + '⁾')}`;
                    fitCategory = '代数模型 (Algebraic)';
                    fitSubtype = '幂律关系';
                    predictFunc = x => a_pow * Math.pow(x, b_pow);
                    break;

                case FIT_TYPES.SINE: // y = a sin(bx + c) + d
                    const a_sin = niceCoeffs[0];
                    const b_sin = niceCoeffs[1];
                    const c_sin = niceCoeffs[2];
                    const d_sin = niceCoeffs[3];
                    
                    // 简化：a=1, b=1, c=0, d=0
                    let sinTerm = `sin(${b_sin === 1 ? 'x' : b_sin + 'x'}${c_sin > 0 ? ' + ' + c_sin : (c_sin < 0 ? ' - ' + (-c_sin) : '')})`;
                    let a_part = a_sin === 1 ? '' : a_sin;
                    let d_part = d_sin === 0 ? '' : (d_sin > 0 ? ' + ' + d_sin : ' - ' + (-d_sin));
                    if (a_sin === 0) sinTerm = '';

                    displayFormula = `y = ${a_part}${sinTerm}${d_part}`;
                    displayFormula = displayFormula.replace(/\+ -/g, '- ').trim();
                    if (displayFormula.startsWith('y = + ')) displayFormula = 'y = ' + displayFormula.substring(6); // 移除开头的正号

                    fitCategory = '超越模型 (Transcendental)';
                    fitSubtype = '周期波动/震荡';
                    predictFunc = x => a_sin * Math.sin(b_sin * x + c_sin) + d_sin;
                    break;
                    
                case FIT_TYPES.GAUSSIAN: // y = A e^[-(x-μ)² / 2σ²]
                    const A_gauss = niceCoeffs[0];
                    const mu_gauss = niceCoeffs[1];
                    const sigma_gauss = niceCoeffs[2];
                    const two_sigma_sq = 2 * sigma_gauss * sigma_gauss;
                    
                    let A_g = A_gauss === 1 ? '' : A_gauss;
                    let mu_g = mu_gauss === 0 ? '' : (mu_gauss > 0 ? `-${mu_gauss}` : `+${-mu_gauss}`);

                    displayFormula = `y = ${A_g}e^[-(x${mu_g})² / ${two_sigma_sq}]`;
                    fitCategory = '超越模型 (Transcendental)';
                    fitSubtype = '钟形分布/峰值';
                    predictFunc = x => A_gauss * Math.exp(-Math.pow(x - mu_gauss, 2) / two_sigma_sq);
                    break;
                    
                case FIT_TYPES.LORENTZIAN: // y = A / (1 + ((x-μ)/σ)² )
                    const A_lor = niceCoeffs[0];
                    const mu_lor = niceCoeffs[1];
                    const sigma_lor = niceCoeffs[2];
                    
                    if (Math.abs(A_lor - 1) < 0.1) {
                        displayFormula = `y = 1 / (1 + ((x${mu_lor >= 0 ? '-'+mu_lor : '+'+(-mu_lor)})/${sigma_lor})²)`;
                        operations.push("振幅A接近1，简化为标准洛伦兹函数");
                    } else {
                        displayFormula = `y = ${A_lor} / (1 + ((x${mu_lor >= 0 ? '-'+mu_lor : '+'+(-mu_lor)})/${sigma_lor})²)`;
                    }
                    displayFormula = displayFormula.replace('+-', '-'); // 清理 -(-mu) 后的符号
                    
                    fitCategory = '超越模型 (Transcendental)';
                    fitSubtype = '共振曲线/展宽线型';
                    predictFunc = x => A_lor / (1 + Math.pow((x - mu_lor) / sigma_lor, 2));
                    break;
                    
                case FIT_TYPES.HYPERBOLIC: // y = a / (b + x)
                    const a_hyp = niceCoeffs[0];
                    const b_hyp = niceCoeffs[1];
                    
                    if (Math.abs(a_hyp - 1) < 0.1) {
                        displayFormula = `y = 1 / (${b_hyp} + x)`;
                        operations.push("系数a接近1，简化为 y = 1/(b+x)");
                    } else if (Math.abs(b_hyp) < 0.1) {
                        displayFormula = `y = ${a_hyp} / x`;
                        operations.push("系数b接近0，简化为 y = a/x");
                    } else {
                        displayFormula = `y = ${a_hyp} / (${b_hyp} + x)`;
                    }

                    fitCategory = '代数模型 (Algebraic)';
                    fitSubtype = '米氏方程/反比例';
                    predictFunc = x => a_hyp / (b_hyp + x);
                    break;
                    
                case FIT_TYPES.LOGISTIC: // y = d + (L-d) / (1 + e^{-k(x-x₀)})
                    const L_logi = niceCoeffs[0];
                    const k_logi = niceCoeffs[1];
                    const x0_logi = niceCoeffs[2];
                    const yMin_logi = niceCoeffs[3];
                    
                    const L_minus_d = L_logi - yMin_logi;
                    let num = L_minus_d;
                    let x0_part = x0_logi === 0 ? '' : (x0_logi > 0 ? ` - ${x0_logi}` : ` + ${-x0_logi}`);

                    displayFormula = `y = ${yMin_logi} + ${num} / (1 + e^[${-k_logi} (x${x0_part})])`;
                    displayFormula = displayFormula.replace(/\+ -/g, '- ');

                    fitCategory = '超越模型 (Transcendental)';
                    fitSubtype = 'S型曲线/生长饱和';
                    predictFunc = x => yMin_logi + L_minus_d / (1 + Math.exp(-k_logi * (x - x0_logi)));
                    break;
                
                case FIT_TYPES.GOMPERTZ: // y = yMin + (yMax - yMin) * exp(-exp(-b(x-c)))
                    const yMin_gomp = niceCoeffs[0];
                    const yMax_gomp = niceCoeffs[1];
                    const b_gomp = niceCoeffs[2];
                    const c_gomp = niceCoeffs[3];
                    
                    const amplitude = yMax_gomp - yMin_gomp;
                    let c_part = c_gomp === 0 ? '' : (c_gomp > 0 ? ` - ${c_gomp}` : ` + ${-c_gomp}`);

                    displayFormula = `y = ${yMin_gomp} + ${amplitude} exp(-exp^[${-b_gomp} (x${c_part})])`;
                    displayFormula = displayFormula.replace(/\+ -/g, '- ');

                    fitCategory = '超越模型 (Transcendental)';
                    fitSubtype = '不对称S型/生物生长';
                    predictFunc = x => yMin_gomp + amplitude * Math.exp(-Math.exp(-b_gomp * (x - c_gomp)));
                    break;

                case FIT_TYPES.MICHAELIS_MENTEN: // y = (Vmax * x) / (Km + x)
                    const a_mm = niceCoeffs[0]; // Vmax
                    const b_mm = niceCoeffs[1]; // Km

                    let a_part_mm = a_mm === 1 ? '' : a_mm;
                    let b_part_mm = b_mm;

                    displayFormula = `y = (${a_part_mm}x) / (${b_part_mm} + x)`;
                    displayFormula = displayFormula.replace(/\+ -/g, '- ').trim();

                    fitCategory = '专业动力学模型 (Kinetics)';
                    fitSubtype = '饱和/酶促反应曲线';
                    predictFunc = x => (a_mm * x) / (b_mm + x);
                    break;
                    
                default:
                    displayFormula = '无法优美化';
                    predictFunc = x => 0; 
                    fitCategory = '未知模型';
                    fitSubtype = '';
                    break;
            }
            
            // 重新计算R²
            r2Optimized = calculateR2FromPrediction(points.map(p => [p[0], p[1]]), predictFunc);

            return {
                formula: displayFormula,
                operations: operations,
                r2: r2Optimized,
                fitCategory: fitCategory,
                fitSubtype: fitSubtype
            };
        }


        // 拟合计算函数 - 完整版本
        function calculateAllFits() {
            if (points.length < 2) {
                updateChart([], null);
                document.getElementById('formulaGrid').innerHTML = '<div style="text-align: center; padding: 20px; color: var(--text-secondary);">请至少输入2个点进行拟合</div>';
                document.getElementById('fitCount').textContent = '0 个结果';
                return;
            }

            const data = points.map(p => [p[0], p[1]]);
            const results = [];
            document.getElementById('formulaGrid').innerHTML = ''; // 清空旧结果
            document.getElementById('fitCount').textContent = '计算中...';
            
            // 1. 线性拟合 (Linear)
            try {
                const linear = regression.linear(data);
                const linearPredict = x => linear.equation[0] + linear.equation[1] * x;
                linear.r2 = calculateR2FromPrediction(data, linearPredict);
                results.push({ 
                    name: '线性拟合 (Linear)', 
                    r2: linear.r2, 
                    rawString: `y = ${linear.equation[1].toFixed(4)}x + ${linear.equation[0].toFixed(4)}`, 
                    points: generateFitPoints(data, linearPredict), 
                    beautify: () => performBeautification('线性拟合', [linear.equation[0], linear.equation[1]], 'y = a + bx', FIT_TYPES.LINEAR)
                });
            } catch (e) { console.error("Linear fit failed:", e); }

            // 2. 多项式拟合 (Polynomial - 2阶, 3阶)
            for (let order = 2; order <= 3; order++) {
                 if (points.length > order) {
                    try {
                        const polynomial = regression.polynomial(data, { order: order });
                        const polyPredict = x => polynomial.equation.reduce((sum, c, i) => sum + c * Math.pow(x, i), 0);
                        polynomial.r2 = calculateR2FromPrediction(data, polyPredict);
                        results.push({ 
                            name: `${order} 阶多项式拟合`, 
                            r2: polynomial.r2, 
                            rawString: `y = ${polynomial.string}`, 
                            points: generateFitPoints(data, polyPredict), 
                            beautify: () => performBeautification(`多项式拟合 (Order ${order})`, polynomial.equation, `y = c₀ + c₁x + ...`, FIT_TYPES.POLYNOMIAL)
                        });
                    } catch (e) { console.error(`Polynomial (Order ${order}) fit failed:`, e); }
                }
            }

            // 3. 指数拟合 (Exponential)
            try {
                const exponential = regression.exponential(data);
                const expPredict = x => exponential.equation[0] * Math.exp(exponential.equation[1] * x);
                exponential.r2 = calculateR2FromPrediction(data, expPredict);
                 results.push({ 
                    name: '指数拟合 (Exponential)', 
                    r2: exponential.r2, 
                    rawString: `y = ${exponential.equation[0].toFixed(4)}e^(${exponential.equation[1].toFixed(4)}x)`, 
                    points: generateFitPoints(data, expPredict), 
                    beautify: () => performBeautification('指数拟合', [exponential.equation[0], exponential.equation[1]], 'y = aeᵇˣ', FIT_TYPES.EXPONENTIAL)
                });
            } catch (e) { console.error("Exponential fit failed:", e); }

            // 4. 对数拟合 (Logarithmic)
            try {
                const logarithmic = regression.logarithmic(data);
                const logPredict = x => logarithmic.equation[0] + logarithmic.equation[1] * Math.log(x);
                logarithmic.r2 = calculateR2FromPrediction(data, logPredict);
                results.push({ 
                    name: '对数拟合 (Logarithmic)', 
                    r2: logarithmic.r2, 
                    rawString: `y = ${logarithmic.equation[1].toFixed(4)}ln(x) + ${logarithmic.equation[0].toFixed(4)}`, 
                    points: generateFitPoints(data, logPredict), 
                    beautify: () => performBeautification('对数拟合', [logarithmic.equation[0], logarithmic.equation[1]], 'y = a + b ln(x)', FIT_TYPES.LOGARITHMIC)
                });
            } catch (e) { console.error("Logarithmic fit failed:", e); }

            // 5. 幂律拟合 (Power)
            try {
                const power = regression.power(data);
                const powerPredict = x => power.equation[0] * Math.pow(x, power.equation[1]);
                power.r2 = calculateR2FromPrediction(data, powerPredict);
                 results.push({ 
                    name: '幂律拟合 (Power)', 
                    r2: power.r2, 
                    rawString: `y = ${power.equation[0].toFixed(4)}x^(${power.equation[1].toFixed(4)})`, 
                    points: generateFitPoints(data, powerPredict), 
                    beautify: () => performBeautification('幂律拟合', [power.equation[0], power.equation[1]], 'y = axᵇ', FIT_TYPES.POWER)
                });
            } catch (e) { console.error("Power fit failed:", e); }
            
            // 6. 正弦拟合 (Sine) - 简化版本: y = a sin(x) + d
            if (points.length >= 2) {
                 try {
                    // 简化：使用平均值和振幅的简化估计
                    const yValues = data.map(p => p[1]);
                    const yMin = Math.min(...yValues);
                    const yMax = Math.max(...yValues);
                    const d = (yMin + yMax) / 2; // 简化：y轴偏移
                    const a = (yMax - yMin) / 2; // 简化：振幅
                    const b = 1.0; // 简化：周期系数
                    const c = 0.0; // 简化：相位
                    
                    const sinePredict = x => a * Math.sin(b * x + c) + d;
                    const sineR2 = calculateR2FromPrediction(data, sinePredict);

                    results.push({ 
                        name: '正弦拟合 (Sine) - 简化', 
                        r2: sineR2, 
                        rawString: `y = ${a.toFixed(4)}sin(${b.toFixed(4)}x + ${c.toFixed(4)}) + ${d.toFixed(4)}`, 
                        points: generateFitPoints(data, sinePredict), 
                        beautify: () => performBeautification('正弦拟合', [a, b, c, d], 'y = a sin(bx + c) + d', FIT_TYPES.SINE)
                    });
                } catch (e) { console.error("Sine fit failed:", e); }
            }
            
            // 7. 高斯拟合 (Gaussian) - 简化版本: y = A e^[-(x-μ)² / 2σ²]
            if (points.length >= 3) {
                 try {
                    // 简化：使用最大值作为A，平均值作为μ，标准差作为σ的简化估计
                    const xValues = data.map(p => p[0]);
                    const yValues = data.map(p => p[1]);
                    const yMax = Math.max(...yValues);
                    const maxIndex = yValues.indexOf(yMax);
                    const xMean = data.reduce((sum, p) => sum + p[0], 0) / data.length;
                    const A = yMax; // 简化：振幅
                    const mu = data[maxIndex][0]; // 简化：均值/中心
                    const sigma = Math.sqrt(xValues.reduce((sum, x) => sum + Math.pow(x - xMean, 2), 0) / xValues.length); // 简化：标准差
                    const sigma_sq = sigma === 0 ? 1 : sigma * sigma; // 避免除零

                    const gaussianPredict = x => A * Math.exp(-Math.pow(x - mu, 2) / (2 * sigma_sq));
                    const gaussianR2 = calculateR2FromPrediction(data, gaussianPredict);

                    results.push({ 
                        name: '高斯拟合 (Gaussian)', 
                        r2: gaussianR2, 
                        rawString: `y = ${A.toFixed(4)}e^[- (x - ${mu.toFixed(4)})² / ${2*sigma_sq.toFixed(4)}]`, 
                        points: generateFitPoints(data, gaussianPredict), 
                        beautify: () => performBeautification('高斯拟合', [A, mu, sigma], 'y = A e^{-(x-μ)² / 2σ²}', FIT_TYPES.GAUSSIAN)
                    });

                    // 【新增】高斯拟合 LM优化
                    try {
                        const initialParams = [A, mu, sigma];
                        const lmResult = levenbergMarquardt(gaussianModel, data, initialParams, gaussianJacobian);
                        
                        if (lmResult.converged) {
                            const lmPredict = x => gaussianModel(lmResult.params, x);
                            const lmR2 = calculateR2FromPrediction(data, lmPredict);
                            
                            if (lmR2 > gaussianR2) {
                                results.push({ 
                                    name: '高斯拟合 (LM优化)', 
                                    r2: lmR2, 
                                    rawString: `y = ${lmResult.params[0].toFixed(4)}e^[- (x - ${lmResult.params[1].toFixed(4)})² / ${2*Math.pow(lmResult.params[2], 2).toFixed(4)}]`, 
                                    points: generateFitPoints(data, lmPredict), 
                                    beautify: () => performBeautification('高斯拟合 (LM优化)', lmResult.params, 'y = A e^{-(x-μ)² / 2σ²}', FIT_TYPES.GAUSSIAN)
                                });
                            }
                        }
                    } catch (e) { console.error("Gaussian LM fit failed:", e); }
                } catch (e) { console.error("Gaussian fit failed:", e); }
            }
            
            // 8. 洛伦兹拟合 (Lorentzian) - 简化版本: y = A / (1 + ((x-μ)/σ)² )
            if (points.length >= 3) {
                 try {
                    // 简化：使用与高斯拟合相似的参数估计
                    const yValues = data.map(p => p[1]);
                    const yMax = Math.max(...yValues);
                    const maxIndex = yValues.indexOf(yMax);
                    const A = yMax; // 简化：振幅/峰高
                    const xMean = data.reduce((sum, p) => sum + p[0], 0) / data.length;
                    const mu = data[maxIndex][0]; // 简化：中心
                    const halfWidth = 1.0; // 简化：半高宽参数 (设置为1.0作为经验值)

                    const lorentzianPredict = x => A / (1 + Math.pow((x - mu) / halfWidth, 2));
                    const lorentzianR2 = calculateR2FromPrediction(data, lorentzianPredict);

                    results.push({ 
                        name: '洛伦兹拟合 (Lorentzian)', 
                        r2: lorentzianR2, 
                        rawString: `y = ${A.toFixed(4)} / (1 + ((x - ${mu.toFixed(4)}) / ${halfWidth.toFixed(4)})²)`, 
                        points: generateFitPoints(data, lorentzianPredict), 
                        beautify: () => performBeautification('洛伦兹拟合', [A, mu, halfWidth], 'y = A / [1 + ((x-μ)/σ)²]', FIT_TYPES.LORENTZIAN)
                    });

                    // 【新增】洛伦兹拟合 LM优化
                    try {
                        const initialParams = [A, mu, halfWidth];
                        const lmResult = levenbergMarquardt(lorentzianModel, data, initialParams, lorentzianJacobian);
                        
                        if (lmResult.converged) {
                            const lmPredict = x => lorentzianModel(lmResult.params, x);
                            const lmR2 = calculateR2FromPrediction(data, lmPredict);
                            
                            if (lmR2 > lorentzianR2) {
                                results.push({ 
                                    name: '洛伦兹拟合 (LM优化)', 
                                    r2: lmR2, 
                                    rawString: `y = ${lmResult.params[0].toFixed(4)} / (1 + ((x - ${lmResult.params[1].toFixed(4)}) / ${lmResult.params[2].toFixed(4)})²)`, 
                                    points: generateFitPoints(data, lmPredict), 
                                    beautify: () => performBeautification('洛伦兹拟合 (LM优化)', lmResult.params, 'y = A / [1 + ((x-μ)/γ)²]', FIT_TYPES.LORENTZIAN)
                                });
                            }
                        }
                    } catch (e) { console.error("Lorentzian LM fit failed:", e); }
                } catch (e) { console.error("Lorentzian fit failed:", e); }
            }
            
            // 9. 双曲拟合 (Hyperbolic) - 简化: y = a / (b + x)
            if (points.length >= 2) { 
                 try {
                    // 简化实现的双曲拟合（假设a和b为经验值）
                    const yValues = data.map(p => p[1]);
                    const xValues = data.map(p => p[0]);
                    const yMax = Math.max(...yValues);
                    const xMean = xValues.reduce((sum, x) => sum + x, 0) / xValues.length;
                    const a = yMax; // 简化：假设a约等于Y最大值
                    const b = xMean > 0 ? xMean : 1.0; // 简化：b约等于X平均值，避免非正值

                    const hyperbolicPredict = x => a / (b + x);
                    const hyperbolicR2 = calculateR2FromPrediction(data, hyperbolicPredict);
                    
                    results.push({ 
                        name: '双曲拟合 (Hyperbolic)', 
                        r2: hyperbolicR2, 
                        rawString: `y = ${a.toFixed(4)} / (${b.toFixed(4)} + x)`, 
                        points: generateFitPoints(data, hyperbolicPredict), 
                        beautify: () => performBeautification('双曲拟合', [a, b], 'y = a / (b + x)', FIT_TYPES.HYPERBOLIC)
                    });
                } catch (e) { console.error("Hyperbolic fit failed:", e); }
            }

            // 10. 有理函数拟合 (Rational) - 简化: y = (ax + b) / (cx + d)
            if (points.length >= 4) { 
                 try {
                    // 简化：使用 y = x / (x + 1) 为起始点 (a=1, b=0, c=1, d=1)
                    const a = 1.0; 
                    const b = 0.0;
                    const c = 1.0;
                    const d = 1.0; 
                    
                    const rationalPredict = x => (a * x + b) / (c * x + d);
                    const rationalR2 = calculateR2FromPrediction(data, rationalPredict);
                    
                    results.push({ 
                        name: '有理函数拟合 (Rational) - 简化', 
                        r2: rationalR2, 
                        rawString: `y = (${a.toFixed(4)}x + ${b.toFixed(4)}) / (${c.toFixed(4)}x + ${d.toFixed(4)})`, 
                        points: generateFitPoints(data, rationalPredict), 
                        // beautify: () => performBeautification('有理函数拟合', [a, b, c, d], 'y = (ax + b) / (cx + d)', FIT_TYPES.RATIONAL) // 暂不实现有理函数优美化
                    });
                } catch (e) { console.error("Rational fit failed:", e); }
            }
            
            // 11. Logistic 拟合 (四参数: L, k, x₀, d)
            if (points.length >= 4) {
                 try {
                    // 简化：使用 y = d + (L-d) / (1 + e^{-k(x-x₀)})
                    const yValues = data.map(p => p[1]);
                    const yMin = Math.min(...yValues);
                    const yMax = Math.max(...yValues);
                    const L = yMax; // 简化：最大渐近线
                    const d = yMin; // 简化：最小渐近线
                    const k = 1.0; // 简化：增长率
                    const x0 = data[Math.floor(data.length / 2)][0]; // 简化：拐点X值
                    
                    const logisticPredict = x => d + (L - d) / (1 + Math.exp(-k * (x - x0)));
                    const logisticR2 = calculateR2FromPrediction(data, logisticPredict);
                    
                    results.push({ 
                        name: 'Logistic 拟合', 
                        r2: logisticR2, 
                        rawString: `y = ${d.toFixed(3)} + (${(L-d).toFixed(3)}) / (1 + e^(-${k.toFixed(3)}(x-${x0.toFixed(3)})))`, 
                        points: generateFitPoints(data, logisticPredict), 
                        beautify: () => performBeautification('Logistic拟合', [L, k, x0, d], 'y = d + (L-d) / (1 + e^{-k(x-x₀)})', FIT_TYPES.LOGISTIC)
                    });
                } catch (e) { console.error("Logistic fit failed:", e); }
            }

            // 12. Gompertz 拟合 (四参数: yMin, yMax, b, c)
            if (points.length >= 4) { 
                 try {
                    // 简化：y = yMin + (yMax - yMin) * exp(-exp(-b(x-c)))
                    const yValues = data.map(p => p[1]);
                    const yMin = Math.min(...yValues);
                    const yMax = Math.max(...yValues);
                    const b = 1.0; // 简化：增长率参数
                    const c = data[Math.floor(data.length / 2)][0]; // 简化：拐点X值

                    const gompertzPredict = x => yMin + (yMax - yMin) * Math.exp(-Math.exp(-b * (x - c)));
                    const gompertzR2 = calculateR2FromPrediction(data, gompertzPredict);
                    
                    results.push({ 
                        name: 'Gompertz 拟合', 
                        r2: gompertzR2, 
                        rawString: `y = ${yMin.toFixed(3)} + (${(yMax-yMin).toFixed(3)}) * exp(-exp(-${b.toFixed(3)}(x-${c.toFixed(3)})))`, 
                        points: generateFitPoints(data, gompertzPredict), 
                        beautify: () => performBeautification('Gompertz拟合', [yMin, yMax, b, c], 'y = a + (b-a) * exp(-exp(-c(x-d)))', FIT_TYPES.GOMPERTZ)
                    });
                } catch (e) { console.error("Gompertz fit failed:", e); }
            }

            // 13. 【新增】米氏方程拟合 (Michaelis-Menten) - y = (Vmax * x) / (Km + x)
            if (points.length >= 3) {
                try {
                    // 使用 Lineweaver-Burk 线性化: 1/y = (Km/Vmax) * (1/x) + (1/Vmax)
                    const mmData = data.filter(p => p[0] > 1e-10 && p[1] > 1e-10) 
                                      .map(p => [1 / p[0], 1 / p[1]]); // [1/x, 1/y]

                    if (mmData.length >= 2) {
                        const linearMM = regression.linear(mmData); // 线性拟合 1/y = B * (1/x) + A
                        const A = linearMM.equation[0]; // 截距 A = 1/Vmax 
                        const B = linearMM.equation[1]; // 斜率 B = Km/Vmax

                        if (A !== 0) {
                            // 从线性系数反推 Michaelis-Menten 系数:
                            const Vmax_a = 1 / A;
                            const Km_b = B / A;

                            const mmPredict = x => (Vmax_a * x) / (Km_b + x);
                            const mmR2 = calculateR2FromPrediction(data, mmPredict);
                            
                            results.push({ 
                                name: '米氏方程拟合 (M-M)', 
                                r2: mmR2, 
                                rawString: `y = (${Vmax_a.toFixed(4)}x) / (${Km_b.toFixed(4)} + x)`, 
                                points: generateFitPoints(data, mmPredict), 
                                beautify: () => performBeautification('米氏方程拟合', [Vmax_a, Km_b], 'y = (Vmax * x) / (Km + x)', FIT_TYPES.MICHAELIS_MENTEN)
                            });

                            // 【新增】米氏方程 LM优化
                            try {
                                const initialParams = [Vmax_a, Km_b];
                                const lmResult = levenbergMarquardt(michaelisMentenModel, data, initialParams, michaelisMentenJacobian);
                                
                                if (lmResult.converged) {
                                    const lmPredict = x => michaelisMentenModel(lmResult.params, x);
                                    const lmR2 = calculateR2FromPrediction(data, lmPredict);
                                    
                                    if (lmR2 > mmR2) {
                                        results.push({ 
                                            name: '米氏方程拟合 (LM优化)', 
                                            r2: lmR2, 
                                            rawString: `y = (${lmResult.params[0].toFixed(4)}x) / (${lmResult.params[1].toFixed(4)} + x)`, 
                                            points: generateFitPoints(data, lmPredict), 
                                            beautify: () => performBeautification('米氏方程拟合 (LM优化)', lmResult.params, 'y = (Vmax * x) / (Km + x)', FIT_TYPES.MICHAELIS_MENTEN)
                                        });
                                    }
                                }
                            } catch (e) { console.error("Michaelis-Menten LM fit failed:", e); }
                        }
                    }
                } catch (e) {
                    console.error("Michaelis-Menten fit failed:", e);
                }
            }


            // 排序并找到最佳拟合
            results.sort((a, b) => b.r2 - a.r2);
            
            const bestFit = results.length > 0 ? results[0] : null;
            
            document.getElementById('fitCount').textContent = `${results.length} 个结果`;

            if (bestFit) {
                // 更新图表为最佳拟合曲线
                updateChart(bestFit.points, bestFit.r2);

                // 渲染结果卡片
                const formulaGrid = document.getElementById('formulaGrid');
                results.forEach((res, index) => {
                    const isBest = index === 0;
                    const beautified = res.beautify ? res.beautify() : {formula: 'N/A', operations: [], r2: res.r2, fitCategory: '未知', fitSubtype: ''};
                    const r2Display = beautified.r2.toFixed(4);
                    const r2Tooltip = `原始R²: ${res.r2.toFixed(4)}`;
                    
                    const card = document.createElement('div');
                    card.className = `formula-card ${isBest ? 'active' : ''}`;
                    card.innerHTML = `
                        <div class="card-header">
                            <span>${res.name}</span>
                            <span class="r2-badge" title="${r2Tooltip}">R²: ${r2Display}</span>
                        </div>
                        <div class="fit-category">${beautified.fitCategory}</div>
                        <div class="fit-subtype">${beautified.fitSubtype}</div>
                        <div class="formula-container-row">
                            <div class="formula-box">
                                <div class="formula-box-label">原始拟合公式 (Raw Formula)</div>
                                <div class="math-display-box raw-box" title="${res.rawString}">${res.rawString}</div>
                            </div>
                            <div class="arrow-separator">
                                &rarr;
                            </div>
                            <div class="formula-box">
                                <div class="formula-box-label">极致优美化公式 (Beautified)</div>
                                <div class="math-display-box beautified-box" title="${beautified.formula}">${beautified.formula}</div>
                            </div>
                        </div>
                        ${beautified.operations.length > 0 ? `
                            <div class="optimization-note">
                                优化操作: ${beautified.operations.join(' | ')}
                            </div>
                        ` : ''}
                    `;
                    formulaGrid.appendChild(card);
                });
            } else {
                 document.getElementById('formulaGrid').innerHTML = '<div style="text-align: center; padding: 20px; color: var(--text-secondary);">无有效拟合结果</div>';
            }
        }

        // =======================================================
        // 【启动】
        // =======================================================

        function initializeExampleData() {
            points = [
                [1.0, 1.2], [2.0, 3.8], [3.0, 8.5], [4.0, 16.2], [5.0, 25.1]
            ];
            points.sort((a, b) => a[0] - b[0]);
            updatePointsList();
            calculateAllFits();
        }

        window.addEventListener('load', () => {
            applyInitialTheme();
            initChart();
            initHorizontalResizer();
            initVerticalResizer();
            initializeExampleData();
            setupInputs();
            initDragHandling();

            const lockBtn = document.getElementById('dragLockBtn');
            if (lockBtn) {
                lockBtn.onclick = () => {
                    dragEnabled = !dragEnabled;
                    
                    const lockedIcon = document.getElementById('lockedIcon');
                    const unlockedIcon = document.getElementById('unlockedIcon');
                    const lockText = document.getElementById('lockText');
                    const canvas = document.getElementById('fittingChart');
                    
                    if (dragEnabled) {
                        lockedIcon.style.display = 'none';
                        unlockedIcon.style.display = 'block';
                        lockBtn.classList.add('active');
                        lockText.textContent = '解锁拖动';
                        canvas.style.cursor = 'grab';
                    } else {
                        lockedIcon.style.display = 'block';
                        unlockedIcon.style.display = 'none';
                        lockBtn.classList.remove('active');
                        lockText.textContent = '锁定拖动';
                        canvas.style.cursor = 'default';
                    }
                };
                
                // 确保初始状态正确显示
                if (dragEnabled) {
                    document.getElementById('lockedIcon').style.display = 'none';
                    document.getElementById('unlockedIcon').style.display = 'block';
                    lockBtn.classList.add('active');
                    document.getElementById('lockText').textContent = '解锁拖动';
                } else {
                    document.getElementById('lockedIcon').style.display = 'block';
                    document.getElementById('unlockedIcon').style.display = 'none';
                    lockBtn.classList.remove('active');
                    document.getElementById('lockText').textContent = '锁定拖动';
                }
            }
        });
    </script>
</body>
</html>