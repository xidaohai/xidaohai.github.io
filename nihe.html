<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>专业曲线拟合分析工具 | Pro Curve Fitting</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/regression@2.0.1/dist/regression.min.js"></script>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.css">
    <style>
        :root {
            /* 浅色模式 (默认) */
            --bg-body: #f0f2f5;
            --bg-card: #ffffff;
            --bg-input: #ffffff;
            --bg-hover: #f9fafb;
            --bg-active: #eff6ff;
            --text-primary: #1f2937;
            --text-secondary: #6b7280;
            --primary-color: #2563eb; /* 科技蓝 */
            --accent-color: #059669; /* 翡翠绿 */
            --danger-color: #dc2626;
            --border-color: #e5e7eb;
            --chart-grid: #f3f4f6;
            --chart-text: #666666;
            --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.05);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.1);
            
            /* 滚动条颜色 (浅色) */
            --scrollbar-track: #f1f1f1;
            --scrollbar-thumb: #c1c1c1;
            --scrollbar-thumb-hover: #a8a8a8;
            
            /* 动态布局变量 */
            --sidebar-width: 320px;
        }

        /* 深色模式变量定义 */
        [data-theme="dark"] {
            --bg-body: #111827;
            --bg-card: #1f2937;
            --bg-input: #374151;
            --bg-hover: #374151;
            --bg-active: #1e3a8a; /* 深蓝背景 */
            --text-primary: #f9fafb;
            --text-secondary: #9ca3af;
            --primary-color: #3b82f6; /* 稍亮的蓝 */
            --accent-color: #10b981;
            --danger-color: #ef4444;
            --border-color: #374151;
            --chart-grid: #374151;
            --chart-text: #9ca3af;
            --shadow-sm: 0 1px 2px 0 rgba(0, 0, 0, 0.3);
            --shadow-md: 0 4px 6px -1px rgba(0, 0, 0, 0.5);
            
            /* 滚动条颜色 (深色) */
            --scrollbar-track: #111827;
            --scrollbar-thumb: #4b5563;
            --scrollbar-thumb-hover: #6b7280;
        }
        
        /* --- 全局滚动条样式优化 --- */
        ::-webkit-scrollbar {
            width: 8px;
            height: 8px;
        }
        
        ::-webkit-scrollbar-track {
            background: var(--scrollbar-track); 
            border-radius: 4px;
        }
         
        ::-webkit-scrollbar-thumb {
            background: var(--scrollbar-thumb); 
            border-radius: 4px;
        }
        
        ::-webkit-scrollbar-thumb:hover {
            background: var(--scrollbar-thumb-hover); 
        }
        
        /* Firefox 适配 */
        * {
            scrollbar-width: thin;
            scrollbar-color: var(--scrollbar-thumb) var(--scrollbar-track);
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
            font-family: 'Segoe UI', Roboto, 'Helvetica Neue', Arial, sans-serif;
        }
        
        body {
            background-color: var(--bg-body);
            color: var(--text-primary);
            line-height: 1.5;
            padding: 20px;
            height: 100vh;
            overflow: hidden; 
            display: flex;
            flex-direction: column;
            transition: background-color 0.3s, color 0.3s;
        }

        /* 顶部栏 */
        header {
            background: var(--bg-card);
            padding: 15px 25px;
            border-bottom: 1px solid var(--border-color);
            display: flex;
            justify-content: space-between;
            align-items: center;
            flex-shrink: 0;
            box-shadow: var(--shadow-sm);
            z-index: 100; /* 提高层级给下拉菜单 */
            transition: background-color 0.3s, border-color 0.3s;
        }

        h1 {
            font-size: 1.25rem;
            font-weight: 700;
            color: var(--text-primary);
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .badge {
            font-size: 0.75rem;
            background: var(--primary-color);
            color: white;
            padding: 2px 8px;
            border-radius: 4px;
            font-weight: 500;
        }

        /* 参考表下拉菜单样式 */
        .nav-item-container {
            position: relative;
            display: flex;
            align-items: center;
        }

        .reference-dropdown {
            position: absolute;
            top: 100%;
            right: 0;
            width: 480px;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 8px;
            box-shadow: var(--shadow-md);
            padding: 20px;
            display: none; /* 默认隐藏 */
            opacity: 0;
            transform: translateY(10px);
            transition: opacity 0.2s, transform 0.2s;
            z-index: 1000;
            margin-top: 10px;
        }

        /* 悬停显示 */
        .nav-item-container:hover .reference-dropdown {
            display: block;
            opacity: 1;
            transform: translateY(0);
        }

        /* 连接区域，防止鼠标移出按钮间隙时菜单消失 */
        .nav-item-container::after {
            content: '';
            position: absolute;
            top: 100%;
            left: 0;
            width: 100%;
            height: 10px;
            background: transparent;
        }

        .ref-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 20px;
        }

        .ref-section h4 {
            font-size: 0.85rem;
            color: var(--text-secondary);
            margin-bottom: 10px;
            border-bottom: 1px solid var(--border-color);
            padding-bottom: 5px;
            font-weight: 600;
        }

        .ref-item {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 6px 0;
            font-size: 0.85rem;
            color: var(--text-primary);
        }

        .ref-formula {
            font-family: 'Times New Roman', serif;
            font-style: italic;
            color: var(--primary-color);
            background: var(--bg-hover);
            padding: 2px 6px;
            border-radius: 4px;
        }

        .chart-icons-grid {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
        }

        .mini-chart-card {
            background: var(--bg-hover);
            border-radius: 6px;
            padding: 10px;
            text-align: center;
            transition: transform 0.2s;
        }
        .mini-chart-card:hover {
            transform: translateY(-2px);
            background: var(--bg-active);
        }

        .mini-chart-svg {
            width: 100%;
            height: 40px;
            stroke: var(--text-primary);
            stroke-width: 2;
            fill: none;
        }

        .mini-label {
            font-size: 0.75rem;
            color: var(--text-secondary);
            margin-top: 5px;
            display: block;
        }

        /* 主布局 */
        .main-layout {
            display: grid;
            grid-template-columns: var(--sidebar-width) 14px 1fr;
            grid-template-rows: 1fr;
            gap: 0; 
            height: calc(100vh - 80px);
            padding-top: 20px;
            overflow: hidden;
        }

        /* 左侧控制面板 */
        .sidebar {
            background: var(--bg-card);
            border-radius: 8px;
            border: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-shadow: var(--shadow-sm);
            min-width: 0;
            transition: background-color 0.3s, border-color 0.3s;
        }

        .panel-header {
            padding: 15px;
            border-bottom: 1px solid var(--border-color);
            font-weight: 600;
            background: var(--bg-hover); /* 使用 hover 背景色作为表头背景 */
            color: var(--text-secondary);
            font-size: 0.9rem;
            white-space: nowrap;
            overflow: hidden;
            text-overflow: ellipsis;
            display: flex;
            justify-content: space-between;
            align-items: center;
            transition: background-color 0.3s, border-color 0.3s;
        }

        .panel-content {
            padding: 15px;
            overflow-y: auto;
            flex: 1;
            overflow-x: hidden; 
        }

        /* 输入组 */
        .input-row {
            display: grid;
            grid-template-columns: 1fr 1fr auto;
            gap: 8px;
            margin-bottom: 15px;
        }

        input[type="number"], input[type="text"] {
            width: 100%;
            padding: 8px;
            border: 1px solid var(--border-color);
            background-color: var(--bg-input);
            color: var(--text-primary);
            border-radius: 4px;
            font-size: 0.9rem;
            transition: all 0.2s;
        }

        input[type="number"]:focus, input[type="text"]:focus {
            outline: none;
            border-color: var(--primary-color);
            box-shadow: 0 0 0 2px rgba(37, 99, 235, 0.1);
        }

        button {
            padding: 8px 16px;
            border: none;
            border-radius: 4px;
            font-size: 0.85rem;
            font-weight: 500;
            cursor: pointer;
            transition: all 0.2s;
            white-space: nowrap;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            gap: 5px;
        }

        .btn-primary { background: var(--primary-color); color: white; }
        .btn-primary:hover { filter: brightness(1.1); }
        
        .btn-danger { background: var(--bg-card); color: var(--danger-color); border: 1px solid var(--danger-color); }
        .btn-danger:hover { background: var(--bg-hover); opacity: 0.8; }

        .btn-ghost { background: transparent; color: var(--text-secondary); }
        .btn-ghost:hover { color: var(--danger-color); }
        
        /* 主题/参考按钮通用样式 */
        .btn-icon-only {
            background: transparent;
            color: var(--text-secondary);
            padding: 8px;
            border-radius: 50%;
            width: 36px;
            height: 36px;
            display: flex;
            align-items: center;
            justify-content: center;
            border: 1px solid var(--border-color);
            cursor: pointer;
            transition: all 0.2s;
        }
        .btn-icon-only:hover {
            background-color: var(--bg-hover);
            color: var(--primary-color);
            border-color: var(--primary-color);
        }

        .btn-group {
            display: flex;
            gap: 8px;
            margin-top: 15px;
            border-top: 1px solid var(--border-color);
            padding-top: 15px;
            flex-wrap: wrap;
        }
        
        .btn-outline {
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            color: var(--text-primary);
            flex: 1;
            min-width: 60px;
        }
        .btn-outline:hover {
            background: var(--bg-hover);
            border-color: var(--primary-color);
            color: var(--primary-color);
        }

        /* 数据列表 */
        .data-table-container {
            border: 1px solid var(--border-color);
            border-radius: 4px;
            max-height: 250px;
            overflow-y: auto;
            overflow-x: hidden;
        }

        .data-row {
            display: flex;
            justify-content: space-between;
            padding: 8px 12px;
            border-bottom: 1px solid var(--border-color);
            font-size: 0.85rem;
            cursor: pointer;
            transition: background-color 0.2s;
        }

        .data-row:hover {
            background-color: var(--bg-hover);
        }

        .data-row.editing {
            background-color: var(--bg-active);
        }

        .data-row:last-child { border-bottom: none; }
        .data-row:nth-child(even) { background-color: var(--bg-hover); }

        .edit-input {
            width: 60px;
            padding: 2px 4px;
            border: 1px solid var(--primary-color);
            border-radius: 3px;
            background: var(--bg-input);
            color: var(--text-primary);
            font-size: 0.8rem;
        }

        .edit-buttons {
            display: flex;
            gap: 4px;
        }

        .edit-btn {
            padding: 2px 6px;
            font-size: 0.7rem;
            border-radius: 3px;
        }

        /* 图表控制区 */
        .chart-controls {
            margin-top: 20px;
            padding-top: 20px;
            border-top: 1px solid var(--border-color);
        }

        .control-item {
            margin-bottom: 12px;
        }
        
        .control-label {
            display: flex;
            justify-content: space-between;
            font-size: 0.8rem;
            color: var(--text-secondary);
            margin-bottom: 4px;
            white-space: nowrap;
        }

        input[type="range"] {
            width: 100%;
            accent-color: var(--primary-color);
            cursor: pointer;
        }

        /* 右侧内容区 */
        .content-area {
            display: flex;
            flex-direction: column;
            gap: 0;
            overflow: hidden;
            min-width: 0;
        }

        /* 图表容器 */
        .chart-wrapper {
            flex: 0 0 auto;
            height: 55%; 
            background: var(--bg-card);
            border-radius: 8px;
            border: 1px solid var(--border-color);
            padding: 15px;
            position: relative;
            min-height: 20px;
            box-shadow: var(--shadow-sm);
            overflow: hidden;
            transition: background-color 0.3s, border-color 0.3s;
        }

        /* --- 横向调节手柄 (上下拖动) --- */
        .resizer-horizontal {
            height: 14px;
            background: transparent;
            cursor: row-resize;
            display: flex;
            justify-content: center;
            align-items: center;
            flex-shrink: 0;
            z-index: 20;
            margin: 4px 0;
        }

        .handle-horizontal {
            width: 48px;
            height: 6px;
            background-color: #d1d5db;
            border-radius: 3px;
            transition: background-color 0.2s, transform 0.2s;
            position: relative;
        }
        
        .handle-horizontal::after {
            content: '';
            position: absolute;
            top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 100%; height: 100%;
            border-radius: 3px;
            box-shadow: inset 0 0 2px rgba(0,0,0,0.1);
        }

        .resizer-horizontal:hover .handle-horizontal {
            background-color: var(--primary-color);
            transform: scaleY(1.2);
        }
        .resizer-horizontal:active .handle-horizontal { background-color: #1d4ed8; }

        /* --- 纵向调节手柄 (左右拖动) --- */
        .resizer-vertical {
            width: 14px;
            height: 100%;
            background: transparent;
            cursor: col-resize;
            display: flex;
            justify-content: center;
            align-items: center;
            z-index: 20;
        }

        .handle-vertical {
            width: 6px;
            height: 48px;
            background-color: #d1d5db;
            border-radius: 3px;
            transition: background-color 0.2s, transform 0.2s;
            position: relative;
        }

        .handle-vertical::after {
            content: '';
            position: absolute;
            top: 50%; left: 50%; transform: translate(-50%, -50%);
            width: 100%; height: 100%;
            border-radius: 3px;
            box-shadow: inset 0 0 2px rgba(0,0,0,0.1);
        }

        .resizer-vertical:hover .handle-vertical {
            background-color: var(--primary-color);
            transform: scaleX(1.2);
        }
        .resizer-vertical:active .handle-vertical { background-color: #1d4ed8; }

        /* 底部公式区 */
        .formulas-wrapper {
            flex: 1;
            background: var(--bg-card);
            border-radius: 8px;
            border: 1px solid var(--border-color);
            display: flex;
            flex-direction: column;
            overflow: hidden;
            box-shadow: var(--shadow-sm);
            min-height: 0;
            transition: background-color 0.3s, border-color 0.3s;
        }

        .formulas-grid {
            display: grid;
            grid-template-columns: repeat(auto-fill, minmax(450px, 1fr));
            gap: 15px;
            padding: 15px;
            overflow-y: auto;
        }

        /* 公式卡片 */
        .formula-card {
            border: 1px solid var(--border-color);
            border-radius: 6px;
            padding: 12px;
            transition: all 0.2s;
            position: relative;
            background: var(--bg-card);
            color: var(--text-primary);
        }

        .formula-card:hover {
            border-color: var(--primary-color);
            box-shadow: var(--shadow-md);
            transform: translateY(-2px);
        }

        .formula-card.active {
            border-color: var(--primary-color);
            background-color: var(--bg-active);
        }

        .card-header {
            display: flex;
            justify-content: space-between;
            margin-bottom: 8px;
            font-size: 0.85rem;
            font-weight: 600;
            color: var(--text-secondary);
        }

        .r2-badge {
            background: rgba(16, 185, 129, 0.1); /* 使用透明度以适应黑夜模式 */
            color: var(--accent-color);
            padding: 2px 6px;
            border-radius: 4px;
            font-family: monospace;
        }

        /* 并排布局 */
        .formula-container-row {
            display: flex;
            align-items: stretch;
            gap: 8px;
            margin-bottom: 8px;
        }

        .formula-box {
            flex: 1;
            display: flex;
            flex-direction: column;
            min-width: 0; 
        }

        .formula-box-label {
            font-size: 0.7rem;
            color: var(--text-secondary);
            margin-bottom: 4px;
            white-space: nowrap;
        }

        .math-display-box {
            font-family: 'Courier New', monospace;
            font-size: 0.85rem;
            padding: 8px;
            border-radius: 4px;
            overflow-x: auto;
            white-space: nowrap;
            height: 100%; 
            display: flex;
            align-items: center;
        }

        .raw-box {
            background: var(--bg-hover);
            color: var(--text-primary);
            border: 1px solid transparent;
        }

        .beautified-box {
            background: rgba(245, 158, 11, 0.1); /* 琥珀色透明度 */
            color: #d97706;
            border: 1px solid rgba(245, 158, 11, 0.3);
            font-weight: 600;
        }
        
        [data-theme="dark"] .beautified-box {
            color: #fbbf24; /* 深色模式下文字更亮 */
        }

        .arrow-separator {
            display: flex;
            align-items: center;
            justify-content: center;
            color: var(--text-secondary);
            font-size: 1.2rem;
            padding-top: 16px; 
        }

        .optimization-note {
            color: var(--text-secondary);
            font-size: 0.75rem;
            margin-top: 6px;
            font-style: italic;
            border-top: 1px dashed var(--border-color);
            padding-top: 6px;
        }

        #fileInput { display: none; }

        /* 图表缩放控制按钮 */
        .chart-zoom-controls {
            position: absolute;
            bottom: 10px;
            right: 10px;
            display: flex;
            gap: 5px;
            z-index: 10;
            background: var(--bg-card);
            border-radius: 6px;
            padding: 4px;
            box-shadow: var(--shadow-md);
            border: 1px solid var(--border-color);
        }

        .zoom-btn {
            width: 32px;
            height: 32px;
            background: var(--bg-card);
            border: 1px solid var(--border-color);
            border-radius: 4px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            color: var(--text-secondary);
            transition: all 0.2s;
            font-size: 16px;
            font-weight: bold;
        }

        .zoom-btn:hover {
            background: var(--bg-hover);
            color: var(--primary-color);
            border-color: var(--primary-color);
        }

        .zoom-btn:active {
            transform: scale(0.95);
        }

        .zoom-btn:disabled {
            opacity: 0.5;
            cursor: not-allowed;
        }

        .zoom-btn:disabled:hover {
            background: var(--bg-card);
            color: var(--text-secondary);
            border-color: var(--border-color);
        }

        /* 响应式 */
        @media (max-width: 768px) {
            .main-layout {
                display: flex; 
                flex-direction: column;
                gap: 10px;
                overflow-y: auto;
            }
            body { overflow: auto; height: auto; }
            .chart-wrapper { height: 350px !important; flex: none; }
            .resizer-horizontal, .resizer-vertical { display: none; }
            .sidebar { width: 100% !important; }
        }
        
        @media (max-width: 600px) {
            .formula-container-row { flex-direction: column; }
            .arrow-separator {
                padding-top: 0;
                transform: rotate(90deg);
                height: 20px;
            }
        }
    </style>
</head>
<body>

    <header>
        <h1>
            <svg width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 3v18h18"/><path d="M18 17l-6-11-6 7"/></svg>
            CurveLab <span class="badge">Pro</span>
        </h1>
        
        <div style="display: flex; align-items: center; gap: 15px;">
            <div style="font-size: 0.85rem; color: var(--text-secondary);" class="subtitle-text">
                专业严谨 · 逻辑分析 · 优美拟合
            </div>
            
            <div class="nav-item-container">
                <button class="btn-icon-only" title="灵感参考表">
                    <svg width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M9 18h6"/><path d="M10 22h4"/><path d="M15.09 14c.18-.9.66-1.68 1.35-2.25 2-1.66 2.56-4.6.57-6.95C15.3 2.62 12.04 1.76 9.4 3.32 6.57 5.03 5.6 8.92 7.22 11.75c.69.57 1.17 1.35 1.35 2.25"/></svg>
                </button>
                
                <div class="reference-dropdown">
                    <div style="text-align: center; margin-bottom: 15px; font-weight: 600; color: var(--primary-color);">常见曲线形态与对应模型参考</div>
                    <div class="ref-grid">
                        <div class="ref-section">
                            <h4>基础线性/非线性</h4>
                            <div class="ref-item">
                                <span>线性</span>
                                <span class="ref-formula">y = ax + b</span>
                            </div>
                            <div class="ref-item">
                                <span>指数</span>
                                <span class="ref-formula">y = Ae<sup>Bx</sup></span>
                            </div>
                            <div class="ref-item">
                                <span>对数</span>
                                <span class="ref-formula">y = A + B ln x</span>
                            </div>
                            <div class="ref-item">
                                <span>幂律</span>
                                <span class="ref-formula">y = Ax<sup>B</sup></span>
                            </div>
                            <div class="ref-item">
                                <span>反比例</span>
                                <span class="ref-formula">y = a + b/x</span>
                            </div>
                        </div>
                        <div class="ref-section">
                            <h4>复杂高级模型</h4>
                            <div class="chart-icons-grid">
                                <div class="mini-chart-card">
                                    <svg class="mini-chart-svg" viewBox="0 0 100 50">
                                        <path d="M10,40 L90,10" />
                                    </svg>
                                    <span class="mini-label">线性增长 (Linear)</span>
                                </div>
                                <div class="mini-chart-card">
                                    <svg class="mini-chart-svg" viewBox="0 0 100 50">
                                        <path d="M10,40 Q50,40 90,10" />
                                    </svg>
                                    <span class="mini-label">指数爆发 (Exp)</span>
                                </div>
                                <div class="mini-chart-card">
                                    <svg class="mini-chart-svg" viewBox="0 0 100 50">
                                        <path d="M10,40 Q30,10 90,10" />
                                    </svg>
                                    <span class="mini-label">对数饱和 (Log)</span>
                                </div>
                                <div class="mini-chart-card">
                                    <svg class="mini-chart-svg" viewBox="0 0 100 50">
                                        <path d="M10,25 Q30,5 50,25 T90,25" />
                                    </svg>
                                    <span class="mini-label">周期波动 (Wave)</span>
                                </div>
                                <div class="mini-chart-card">
                                    <svg class="mini-chart-svg" viewBox="0 0 100 50">
                                        <path d="M10,40 L30,10 L50,40 L70,10 L90,40" />
                                    </svg>
                                    <span class="mini-label">振荡衰减 (Oscillation)</span>
                                </div>
                                <div class="mini-chart-card">
                                    <svg class="mini-chart-svg" viewBox="0 0 100 50">
                                        <path d="M10,10 L50,40 L90,10" />
                                    </svg>
                                    <span class="mini-label">抛物线 (Parabola)</span>
                                </div>
                                <div class="mini-chart-card">
                                    <svg class="mini-chart-svg" viewBox="0 0 100 50">
                                        <path d="M10,40 L30,40 L50,10 L70,10 L90,40" />
                                    </svg>
                                    <span class="mini-label">阶梯函数 (Step)</span>
                                </div>
                                <div class="mini-chart-card">
                                    <svg class="mini-chart-svg" viewBox="0 0 100 50">
                                        <path d="M10,25 L30,25 L50,40 L70,40 L90,25" />
                                    </svg>
                                    <span class="mini-label">S型曲线 (Sigmoid)</span>
                                </div>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <button class="btn-icon-only" onclick="toggleTheme()" id="themeBtn" title="切换明暗模式">
                <svg id="moonIcon" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M12 3a6 6 0 0 0 9 9 9 9 0 1 1-9-9Z"/></svg>
                <svg id="sunIcon" style="display: none;" width="20" height="20" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="4"/><path d="M12 2v2"/><path d="M12 20v2"/><path d="m4.93 4.93 1.41 1.41"/><path d="m17.66 17.66 1.41 1.41"/><path d="M2 12h2"/><path d="M20 12h2"/><path d="m6.34 17.66-1.41 1.41"/><path d="m19.07 4.93-1.41 1.41"/></svg>
            </button>
        </div>
    </header>

    <div class="main-layout" id="mainLayout">
        <aside class="sidebar" id="sidebar">
            <div class="panel-header">数据点管理 (Data Management)</div>
            <div class="panel-content">
                <p style="font-size: 0.85rem; color: var(--text-secondary); margin-bottom: 10px;">
                    至少需要 2 个点进行拟合。拖动画布上的点可编辑。
                </p>
                <div class="input-row">
                    <input type="number" id="xInput" placeholder="X 值" step="any">
                    <input type="number" id="yInput" placeholder="Y 值" step="any">
                    <button class="btn-primary" onclick="addPoint()">添加</button>
                </div>

                <div class="data-table-container" id="pointsList">
                    </div>
                
                <div class="btn-group">
                    <button class="btn-outline" onclick="initializeExampleData()">载入示例</button>
                    <button class="btn-outline" onclick="document.getElementById('fileInput').click()">导入</button>
                    <input type="file" id="fileInput" onchange="importTxt(this)" accept=".txt">
                    <button class="btn-outline" onclick="exportTxt()">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"/><path d="M14 2v6h6"/></svg>
                        导出
                    </button>
                    <button class="btn-danger" onclick="clearAllData()">
                        <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M3 6h18"/><path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6"/><path d="M10 11v6"/><path d="M14 11v6"/></svg>
                        清空
                    </button>
                </div>
                
                <div class="chart-controls">
                    <div class="control-item">
                        <div style="display: flex; justify-content: space-between;">
                            <label class="control-label" for="dragLockBtn">点拖动与编辑 (Drag & Edit)</label>
                            <button id="dragLockBtn" class="btn-primary" style="font-size: 0.75rem; padding: 4px 8px; background: var(--accent-color);">锁定拖动</button>
                        </div>
                    </div>
                    <div class="control-item">
                        <button class="btn-primary" onclick="calculateAllFits()" style="width: 100%;">
                            <svg width="16" height="16" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M18 17l-6-11-6 7"/><path d="M3 3v18h18"/></svg>
                            计算拟合
                        </button>
                    </div>

                    <div class="control-item">
                        <div class="control-label">
                            <span>连接方式 (Tension)</span>
                            <span id="tensionVal">直线</span>
                        </div>
                        <input type="range" min="0" max="0.6" step="0.1" value="0" oninput="updateChartConfig(this.value, 'tension')">
                        <div style="display:flex; justify-content:space-between; font-size:0.6rem; color: var(--text-secondary); margin-top:2px;">
                            <span>0</span><span>0.6</span>
                        </div>
                    </div>

                    <div class="control-item">
                        <div class="control-label">
                            <span>数据点大小 (Point Size)</span>
                            <span id="radiusVal">4px</span>
                        </div>
                        <input type="range" min="1" max="7" step="1" value="4" oninput="updateChartConfig(this.value, 'radius')">
                    </div>
                </div>
            </div>
        </aside>

        <div class="resizer-vertical" id="verticalDragHandle">
            <div class="handle-vertical" title="左右拖动调整侧边栏宽度"></div>
        </div>

        <main class="content-area" id="contentArea">
            <div class="chart-wrapper" id="chartWrapper">
                <canvas id="fittingChart"></canvas>
                <div class="chart-zoom-controls">
                    <button class="zoom-btn" id="zoomOutBtn" title="缩小视图" onclick="zoomChart(0.8)">−</button>
                    <button class="zoom-btn" id="zoomResetBtn" title="重置视图" onclick="resetZoom()">↺</button>
                    <button class="zoom-btn" id="zoomInBtn" title="放大视图" onclick="zoomChart(1.2)">+</button>
                </div>
            </div>
            
            <div class="resizer-horizontal" id="horizontalDragHandle">
                <div class="handle-horizontal" title="上下拖动调整区域大小"></div>
            </div>

            <div class="formulas-wrapper" id="formulasWrapper">
                <div class="panel-header">
                    <div style="display:flex; align-items:center; gap:10px;">
                        <span>拟合模型分析 (Fitting Analysis)</span>
                    </div>
                    <div style="display:flex; gap:10px; align-items:center;">
                        <span style="font-size: 0.75rem; font-weight: normal; color: var(--text-secondary);">* R² 越接近 1 拟合度越高</span>
                    </div>
                </div>
                <div class="formulas-grid" id="formulaGrid">
                    <div style="grid-column: 1/-1; text-align: center; color: var(--text-secondary); padding: 50px;">
                        加载中...请在左侧输入数据并点击 “计算拟合”
                    </div>
                </div>
            </div>
        </main>
    </div>


    <script>
        // --- 全局配置 ---
        let chart = null;
        let points = []; // Array of [x, y] pairs
        let editingIndex = -1;
        let dragEnabled = true;
        let baseLineWidth = 2.5;
        let basePointRadius = 4;
        let currentZoomLevel = 1.0;
        let initialXRange = 0;
        let initialYRange = 0;

        const chartConfig = {
            tension: 0, // 0 for straight lines
            radius: basePointRadius // 4px
        };

        // --- 数据操作 ---

        function addPoint() {
            const xInput = document.getElementById('xInput');
            const yInput = document.getElementById('yInput');
            const x = parseFloat(xInput.value);
            const y = parseFloat(yInput.value);

            if (!isNaN(x) && !isNaN(y)) {
                points.push([x, y]);
                points.sort((a, b) => a[0] - b[0]); // 保持数据点按 X 排序
                xInput.value = '';
                yInput.value = '';
                updatePointsList();
                calculateAllFits();
            } else {
                alert("请输入有效的数字");
            }
        }

        function removePoint(index) {
            points.splice(index, 1);
            if (editingIndex === index) {
                editingIndex = -1;
            } else if (editingIndex > index) {
                editingIndex--;
            }
            updatePointsList();
            calculateAllFits();
        }

        function clearAllData() {
            if (confirm("确定要清空所有数据点吗？")) {
                points = [];
                editingIndex = -1;
                updatePointsList();
                calculateAllFits();
                resetZoom();
            }
        }

        function initializeExampleData() {
            points = [
                [0, 1.1],
                [1, 2.3],
                [2, 3.8],
                [3, 5.5],
                [4, 7.2],
                [5, 9.4],
                [6, 12.1],
                [7, 14.5],
                [8, 18.0],
                [9, 21.3],
                [10, 25.0]
            ];
            points.sort((a, b) => a[0] - b[0]);
            updatePointsList();
            calculateAllFits();
        }
        
        // --- 拟合计算 ---

        /**
         * 简化的非线性优化器（自适应梯度下降）
         * 用于在没有外部库的情况下拟合非线性模型。
         */
        function LMA_fit(data, model, initialParams, maxIterations = 2000, tolerance = 1e-8, step = 1e-4) {
            let params = [...initialParams];
            let numParams = params.length;
            let numData = data.length;
            
            // 检查初始参数是否有效
            if (params.some(p => isNaN(p) || !isFinite(p))) {
                console.error("LMA_fit: Invalid initial parameters.");
                return { parameters: initialParams, r2: -1, points: [] };
            }

            function calculateResiduals(p) {
                return data.map(([x, y]) => y - model(p, x));
            }

            function calculateSumOfSquares(p) {
                const residuals = calculateResiduals(p);
                return residuals.reduce((sum, r) => sum + r * r, 0);
            }

            // 有限差分雅可比近似：J[i, j] = d(r_i) / d(p_j)
            function calculateJacobian(p) {
                const J = [];
                for (let i = 0; i < numData; i++) {
                    const row = [];
                    for (let j = 0; j < numParams; j++) {
                        const p_plus = [...p];
                        p_plus[j] += step;
                        const p_minus = [...p];
                        p_minus[j] -= step;

                        // d(r_i)/d(p_j) = - d/d(p_j) [model(p, x_i)]
                        let deriv = 0;
                        try {
                            deriv = (model(p_plus, data[i][0]) - model(p_minus, data[i][0])) / (2 * step);
                        } catch (e) {
                            // Catch numerical errors (e.g., log(negative))
                            return null;
                        }
                        row.push(-deriv); 
                    }
                    J.push(row);
                }
                return J;
            }

            // 梯度计算: g = J^T * residuals
            function simpleGradientDescent(p) {
                const residuals = calculateResiduals(p);
                const J = calculateJacobian(p);
                if (!J) return null; // Jacobian calculation failed
                
                const gradient = new Array(numParams).fill(0);
                for (let j = 0; j < numParams; j++) {
                    let sum = 0;
                    for (let i = 0; i < numData; i++) {
                        sum += J[i][j] * residuals[i];
                    }
                    gradient[j] = sum;
                }
                return gradient;
            }

            let lambda = 1e-4; // 初始步长（学习率）
            let SS_old = calculateSumOfSquares(params);
            
            const avgY = data.reduce((sum, d) => sum + d[1], 0) / numData;
            const SS_total = data.reduce((sum, d) => sum + Math.pow(d[1] - avgY, 2), 0);
            
            if (SS_total < 1e-10) { // 避免除以零
                return { parameters: params, r2: 1, points: data.map(p => [p[0], avgY]) };
            }

            for (let iter = 0; iter < maxIterations; iter++) {
                const gradient = simpleGradientDescent(params);
                if (!gradient) break; // 梯度计算失败，退出

                let newParams = [...params];
                let maxChange = 0;
                
                for (let j = 0; j < numParams; j++) {
                    // 自适应步长更新
                    let change = lambda * gradient[j];
                    newParams[j] = params[j] + change;
                    maxChange = Math.max(maxChange, Math.abs(change));
                }
                
                // 检查参数的有效性
                if (newParams.some(p => isNaN(p) || !isFinite(p))) {
                    lambda *= 0.1; // 大幅减小步长
                    continue; 
                }

                const SS_new = calculateSumOfSquares(newParams);

                if (SS_new < SS_old) {
                    // 改进，接受变化，增加步长
                    params = newParams;
                    SS_old = SS_new;
                    lambda *= 1.2; 
                } else {
                    // 未改进，拒绝变化，减小步长
                    lambda *= 0.5;
                }

                if (maxChange < tolerance) break;
                if (lambda < 1e-12) break; // 步长过小，视为收敛
            }
            
            const SS_residual = calculateSumOfSquares(params);
            const R2 = 1 - (SS_residual / SS_total);

            // 保证 R2 不低于 0
            const finalR2 = Math.max(0, R2);

            return { 
                parameters: params, 
                r2: finalR2, 
                predict: (x) => model(params, x),
                points: data.map(([x]) => [x, model(params, x)]) 
            };
        }

        // --- 模型函数定义 ---
        const model_sigmoid = (p, x) => {
            // p = [L, k, x0]
            // L: max asymptote, k: growth rate, x0: inflection point
            return p[0] / (1 + Math.exp(-p[1] * (x - p[2])));
        };

        const model_gaussian = (p, x) => {
            // p = [a, b, c, d]
            // a: amplitude, b: center (mean), c: width (std dev), d: offset
            // c must be > 0.
            const c_safe = Math.max(1e-6, Math.abs(p[2]));
            return p[0] * Math.exp(-(x - p[1]) * (x - p[1]) / (2 * c_safe * c_safe)) + p[3];
        };

        const model_sine = (p, x) => {
            // p = [A, B, C, D]
            // A: Amplitude, B: Frequency, C: Phase Shift, D: Offset
            return p[0] * Math.sin(p[1] * x + p[2]) + p[3];
        };
        
        // --- 初始参数猜测 ---
        function getInitialGuesses(points) {
            const xValues = points.map(p => p[0]);
            const yValues = points.map(p => p[1]);
            const minX = Math.min(...xValues);
            const maxX = Math.max(...xValues);
            const minY = Math.min(...yValues);
            const maxY = Math.max(...yValues);
            const midX = (minX + maxX) / 2;
            const rangeY = maxY - minY;
            
            const avgY = (minY + maxY) / 2;
            const xRange = maxX - minX;

            // Find index of max Y for Gaussian/Sine center/start guess
            const maxYIndex = yValues.indexOf(maxY);
            const xAtMaxY = xValues[maxYIndex];

            return {
                // Sigmoid [L, k, x0]
                sigmoid: [
                    maxY + rangeY * 0.1, // L (Max asymptote), slight overshoot
                    2 / xRange,          // k (Growth rate), reasonable for xRange
                    midX                 // x0 (Midpoint)
                ],
                // Gaussian [a, b, c, d]
                gaussian: [
                    rangeY,              // a (Amplitude/Peak Height)
                    xAtMaxY,             // b (Center/Mean)
                    xRange / 5,          // c (Width/StdDev), guess 1/5 of range
                    minY                 // d (Offset)
                ],
                // Sine [A, B, C, D]
                sine: [
                    rangeY / 2,          // A (Amplitude)
                    2 * Math.PI / xRange, // B (Frequency - aiming for roughly one cycle in range)
                    0,                   // C (Phase Shift)
                    avgY                 // D (Vertical Offset)
                ]
            };
        }
        
        // --- 拟合计算主函数 ---

        function calculateAllFits() {
            if (points.length < 2) {
                const grid = document.getElementById('formulaGrid');
                grid.innerHTML = '<div style="grid-column: 1/-1; text-align: center; color: var(--text-secondary); padding: 50px;">数据点不足 (至少需要 2 个点)</div>';
                updateChart(points, [], '无拟合');
                initialXRange = 0; // 重置范围
                initialYRange = 0;
                return;
            }
            
            // 确保更新了初始范围 (只在有数据时计算一次或重置后计算一次)
            if (initialXRange === 0) {
                const xValues = points.map(p => p[0]);
                const yValues = points.map(p => p[1]);
                const minX = Math.min(...xValues);
                const maxX = Math.max(...xValues);
                const minY = Math.min(...yValues);
                const maxY = Math.max(...yValues);
                initialXRange = maxX - minX;
                initialYRange = maxY - minY;
            }


            const results = [];
            
            // --- 初始参数猜测 ---
            const initialGuesses = getInitialGuesses(points);

            // --- 1. 线性拟合 (Linear) ---
            const linearRes = regression.linear(points);
            results.push(createFitResult('线性拟合 (Linear)', linearRes, 'y = {0}x + {1}', (c) => `y = ${c[0]}x + ${c[1]}`));

            // --- 2. 指数拟合 (Exponential) ---
            const expRes = regression.exponential(points);
            results.push(createFitResult('指数拟合 (Exp)', expRes, 'y = {0}e^{{1}x}', (c) => `y = ${c[0]}e^(${c[1]}x)`));

            // --- 3. 对数拟合 (Logarithmic) ---
            const logData = points.filter(p => p[0] > 0).map(p => [Math.log(p[0]), p[1]]);
            if (logData.length >= 2) {
                const logRes = regression.linear(logData);
                const a = logRes.equation[1];
                const b = logRes.equation[0];
                const predict = x => a * Math.log(x) + b;
                const logFit = { r2: logRes.r2, equation: [a, b], predict: predict, points: points.map(p => [p[0], predict(p[0])]) };
                results.push(createFitResult('对数拟合 (Log)', logFit, 'y = {0}ln(x) + {1}', (c) => `y = ${c[0]}ln(x) + ${c[1]}`));
            }

            // --- 4. 幂律拟合 (Power) ---
            const powerData = points.filter(p => p[0] > 0 && p[1] > 0).map(p => [Math.log(p[0]), Math.log(p[1])]);
            if (powerData.length >= 2) {
                const powerRes = regression.linear(powerData);
                const a = Math.exp(powerRes.equation[0]);
                const b = powerRes.equation[1];
                const predict = x => a * Math.pow(x, b);
                const powerFit = { r2: powerRes.r2, equation: [a, b], predict: predict, points: points.map(p => [p[0], predict(p[0])]) };
                results.push(createFitResult('幂律拟合 (Power)', powerFit, 'y = {0}x^{{1}}', (c) => `y = ${c[0]}x^(${c[1]})`));
            }
            
            // --- 5. 反比例拟合 (Inverse) ---
            const invData = points.filter(p => p[0] !== 0).map(p => [1/p[0], p[1]]);
            if (invData.length >= 2) {
                const invRes = regression.linear(invData);
                const a = invRes.equation[1];
                const b = invRes.equation[0];
                const predict = x => a + b/x;
                results.push({ name: '反比例拟合 (Inverse)', r2: invRes.r2, equation: [a, b], rawString: `y = ${a} + ${b}/x`, predict: predict, points: points.map(p => [p[0], predict(p[0])]), beautify: () => beautifyNumbers([a, b], ['a', 'b'], (nums) => `y = ${nums[0]} + \\frac{${nums[1]}}{x}`) });
            }

            // --- 6. S型曲线拟合 (Sigmoid) - 实际 LMA 拟合 ---
            if (points.length >= 3) {
                const sigmoidRes = LMA_fit(points, model_sigmoid, initialGuesses.sigmoid);
                if (sigmoidRes.r2 >= 0) { // 检查拟合是否失败
                    results.push(createFitResult('S型拟合 (Sigmoid)', { r2: sigmoidRes.r2, equation: sigmoidRes.parameters, predict: sigmoidRes.predict, points: sigmoidRes.points }, 
                        'y = \\frac{{0}}{1 + e^{-{1}(x-{2})}}', 
                        (c) => `y = ${c[0]} / (1 + exp(-${c[1]} * (x - ${c[2]})))`));
                }
            }

            // --- 7. 高斯曲线拟合 (Gaussian) - 实际 LMA 拟合 ---
            if (points.length >= 4) {
                const gaussianRes = LMA_fit(points, model_gaussian, initialGuesses.gaussian);
                if (gaussianRes.r2 >= 0) {
                    results.push(createFitResult('高斯拟合 (Gaussian)', { r2: gaussianRes.r2, equation: gaussianRes.parameters, predict: gaussianRes.predict, points: gaussianRes.points }, 
                        'y = {0} e^{-\\frac{(x-{1})^2}{2{2}^2}} + {3}', 
                        (c) => `y = ${c[0]} * exp(-(x - ${c[1]})^2 / (2 * ${c[2]}^2)) + ${c[3]}`));
                }
            }

            // --- 8. 周期拟合 (Sine) - 实际 LMA 拟合 ---
            if (points.length >= 4) {
                const sineRes = LMA_fit(points, model_sine, initialGuesses.sine);
                if (sineRes.r2 >= 0) {
                    results.push(createFitResult('周期拟合 (Sine)', { r2: sineRes.r2, equation: sineRes.parameters, predict: sineRes.predict, points: sineRes.points }, 
                        'y = {0} \\sin({1}x + {2}) + {3}', 
                        (c) => `y = ${c[0]} * sin(${c[1]} * x + ${c[2]}) + ${c[3]}`));
                }
            }
            
            results.sort((a, b) => b.r2 - a.r2);
            renderFormulas(results);
            if (results.length > 0) {
                updateChart(points, results[0].points, results[0].name);
            }
        }

        function createFitResult(name, resObj, latexTemplate, rawStrBuilder) {
            return {
                name: name,
                r2: resObj.r2,
                equation: resObj.equation,
                rawString: rawStrBuilder(resObj.equation.map(n => parseFloat(n.toPrecision(5)))),
                predict: resObj.predict,
                points: resObj.points,
                beautify: () => performBeautification(name, resObj.equation, latexTemplate)
            };
        }
        
        function performBeautification(type, coeffs, template) {
            let operations = [];
            // 对非线性模型，放松取整限制，优先保留 3-4 位有效数字
            const isNonLinear = type.includes('Sigmoid') || type.includes('Gaussian') || type.includes('Sine');
            
            let niceCoeffs = coeffs.map((val, idx) => {
                const absVal = Math.abs(val);
                
                // 忽略极小项 (例如 < 1e-6)
                if (absVal < 0.000001) {
                    if (isNonLinear) {
                         // 对非线性项，零系数可能导致模型退化，此处不强制置零
                    } else {
                        operations.push(`系数[${idx}] ${val.toPrecision(3)} ≈ 0 (忽略极小项)`);
                        return 0;
                    }
                }

                // 尝试取整 (误差在 1% 以内)
                const rounded = Math.round(val);
                if (!isNonLinear && Math.abs(val - rounded) < 0.01 * Math.max(1, absVal)) {
                    if (Math.abs(val - rounded) > 1e-10) {
                        operations.push(`系数 ${val.toFixed(4)} → 取整为 ${rounded}`);
                    }
                    return rounded;
                }
                
                // 非线性模型或更精确保留 4 位有效数字
                return parseFloat(val.toPrecision(4));
            });
            
            let displayFormula = template.replace(/{(\d)}/g, (match, index) => {
                const value = niceCoeffs[parseInt(index)];
                return value;
            });
            
            // 进一步简化公式显示：移除 + 0 项和 +/- 后的 -
            displayFormula = displayFormula
                .replace(/\s*([+-])\s*0(?![^x^/])/g, '') // 移除 +0 或 -0 (不跟随 x, ^, /)
                .replace(/\s*\+\s*-/g, ' - ') // 将 + - 替换为 -
                .replace(/x\^1/g, 'x') // 移除 x^1
                .replace(/\s*1x/g, 'x'); // 移除 1x (例如 y = 1x + 2 变为 y = x + 2)
            
            if (operations.length === 0) {
                if (isNonLinear) {
                    operations.push("非线性拟合，保留四位有效数字");
                } else {
                    operations.push("保留三位有效数字");
                }
            }
            
            return { formula: displayFormula, notes: operations };
        }
        
        function beautifyNumbers(coeffs, names, formatter) {
            let operations = [];
            let niceCoeffs = coeffs.map((val, i) => {
                const rounded = Math.round(val);
                if (Math.abs(val - rounded) < 0.1) {
                    operations.push(`系数 ${names[i]} (${val.toFixed(3)}) → 取整为 ${rounded}`);
                    return rounded;
                }
                return parseFloat(val.toFixed(2));
            });
            
            if (operations.length === 0) operations.push("保留两位有效小数");

            return { formula: formatter(niceCoeffs), notes: operations };
        }

        function renderFormulas(results) {
            const grid = document.getElementById('formulaGrid');
            grid.innerHTML = '';

            results.forEach((res, idx) => {
                const beautified = res.beautify();
                const card = document.createElement('div');
                card.className = `formula-card ${idx === 0 ? 'active' : ''}`;
                
                // 只有可计算的拟合卡片才添加点击事件来更新图表
                if (res.points.length > 0) { // 所有实际计算的模型 points.length > 0
                    card.onclick = () => {
                        document.querySelectorAll('.formula-card').forEach(c => c.classList.remove('active'));
                        card.classList.add('active');
                        updateChart(points, res.points, res.name);
                    };
                }
                
                // R² 徽章
                const r2Display = res.r2 >= 0 ? res.r2.toFixed(4) : 'N/A';
                const r2Class = res.r2 > 0 ? 'r2-badge' : 'r2-badge opacity-50'; // R2 <= 0 时降低透明度

                card.innerHTML = `
                    <div class="card-header">
                        <span>${res.name}</span>
                        <span class="${r2Class}">R² = ${r2Display}</span>
                    </div>
                    <div class="formula-container-row">
                        <div class="formula-box">
                            <div class="formula-box-label">原始公式 (Raw)</div>
                            <div class="math-display-box raw-box">${res.rawString}</div>
                        </div>
                        <div class="arrow-separator">→</div>
                        <div class="formula-box">
                            <div class="formula-box-label">✨ 优美化公式 (Beautified)</div>
                            <div class="math-display-box beautified-box">
                                <span class="katex-display">$$${beautified.formula}$$</span>
                            </div>
                        </div>
                    </div>
                    <div class="optimization-note">
                        <strong>优化/注释:</strong> ${beautified.notes.join(' | ')}
                    </div>
                `;
                grid.appendChild(card);
                
                // 重新渲染 KaTeX (确保公式正确显示)
                katex.render(beautified.formula, card.querySelector('.katex-display'), {
                    throwOnError: false,
                    displayMode: true
                });
            });
            
            if (results.length === 0) {
                grid.innerHTML = '<div style="grid-column: 1/-1; text-align: center; color: var(--text-secondary); padding: 50px;">当前数据不足以进行拟合或所有拟合均失败。</div>';
            }
        }
        
        // --- 图表绘制与配置 ---

        function updateChartConfig(value, type) {
            if (type === 'tension') {
                chartConfig.tension = parseFloat(value);
                document.getElementById('tensionVal').textContent = value === '0' ? '直线' : value;
                // 更新图表
                if (chart) {
                    chart.data.datasets[1].tension = chartConfig.tension;
                    chart.update('none'); // 无动画更新
                }
            } else if (type === 'radius') {
                basePointRadius = parseInt(value);
                chartConfig.radius = basePointRadius;
                document.getElementById('radiusVal').textContent = `${basePointRadius}px`;
                // 重新计算并更新图表
                calculateAllFits();
            }
        }

        function initChart() {
            const ctx = document.getElementById('fittingChart').getContext('2d');
            
            const isDark = document.documentElement.getAttribute('data-theme') === 'dark';
            const textColor = getComputedStyle(document.documentElement).getPropertyValue('--chart-text').trim();
            const gridColor = getComputedStyle(document.documentElement).getPropertyValue('--chart-grid').trim();

            chart = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [
                        {
                            label: '原始数据 (Raw)',
                            data: [],
                            backgroundColor: '#dc2626',
                            borderColor: '#dc2626',
                            pointRadius: basePointRadius,
                            pointHoverRadius: basePointRadius + 2,
                            order: 1
                        },
                        {
                            type: 'line',
                            label: '拟合线',
                            data: [],
                            borderColor: '#2563eb',
                            borderWidth: baseLineWidth,
                            fill: false,
                            tension: chartConfig.tension,
                            pointRadius: 0,
                            order: 2
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: {
                        duration: 0 // 初始禁用动画，在 updateChart 启用
                    },
                    plugins: {
                        tooltip: {
                            callbacks: {
                                label: function(context) {
                                    if (context.dataset.order === 1) {
                                        return `(X: ${context.parsed.x.toFixed(3)}, Y: ${context.parsed.y.toFixed(3)}) - ${context.dataset.label}`;
                                    } else {
                                        return `预测值 (X: ${context.parsed.x.toFixed(3)}, Y: ${context.parsed.y.toFixed(3)}) - ${context.dataset.label}`;
                                    }
                                }
                            }
                        },
                        legend: {
                            labels: {
                                color: textColor,
                                font: {
                                    size: 14
                                }
                            }
                        },
                        // 启用 ChartJS-Pinch-Zoom 插件的配置
                        zoom: {
                            pan: {
                                enabled: true,
                                mode: 'xy',
                                threshold: 5
                            },
                            zoom: {
                                wheel: {
                                    enabled: true,
                                },
                                pinch: {
                                    enabled: true
                                },
                                mode: 'xy',
                                onZoomComplete: ({chart}) => {
                                    // 缩放完成后，强制更新图表以应用动态线宽/点半径
                                    const xScale = chart.scales.x;
                                    const newXRange = xScale.max - xScale.min;
                                    
                                    if (initialXRange > 0) {
                                        currentZoomLevel = newXRange / initialXRange;
                                    } else {
                                        currentZoomLevel = 1.0;
                                    }
                                    
                                    // 获取当前的拟合线数据和标签
                                    const currentFitPoints = chart.data.datasets[1].data.map(d => [d.x, d.y]);
                                    const currentLabel = chart.data.datasets[1].label;
                                    updateChart(points, currentFitPoints, currentLabel);
                                }
                            }
                        }
                    },
                    scales: {
                        x: {
                            grid: {
                                color: gridColor
                            },
                            ticks: {
                                color: textColor
                            },
                            title: {
                                display: true,
                                text: 'X Axis',
                                color: textColor
                            }
                        },
                        y: {
                            grid: {
                                color: gridColor
                            },
                            ticks: {
                                color: textColor
                            },
                            title: {
                                display: true,
                                text: 'Y Axis',
                                color: textColor
                            }
                        }
                    },
                    // 启用交互
                    interaction: {
                        mode: 'nearest',
                        intersect: false
                    }
                }
            });
        }

        function updateChart(rawPoints, fitPoints, label) {
            if (!chart) return;
            
            const scatterData = rawPoints.map(p => ({x: p[0], y: p[1]}));
            let lineData = [];

            if (fitPoints.length > 0) {
                // 如果拟合线数据有效，则使用它
                lineData = fitPoints.map(p => ({x: p[0], y: p[1]}));
                lineData.sort((a, b) => a.x - b.x);
            }
            
            // --- 新增: 根据缩放级别调整线宽和点半径 ---
            // currentZoomLevel 越小 (放大效果), 1/sqrt(currentZoomLevel) 越大 -> 动态尺寸越小
            const visualFactor = 1 / Math.sqrt(currentZoomLevel); 
            
            // 根据基准值和视觉因子动态调整，并限制最小值，防止线/点消失或过大
            const dynamicLineWidth = Math.max(0.5, Math.min(6, baseLineWidth / visualFactor)); 
            const dynamicPointRadius = Math.max(1, Math.min(10, basePointRadius / visualFactor)); 
            // ------------------------------------------------

            chart.data.datasets = [
                {
                    label: '原始数据 (Raw)',
                    data: scatterData,
                    backgroundColor: '#dc2626',
                    borderColor: '#dc2626',
                    pointRadius: dynamicPointRadius, // 使用动态半径
                    pointHoverRadius: dynamicPointRadius + 2,
                    order: 1
                },
                {
                    type: 'line',
                    label: label || '拟合线',
                    data: lineData,
                    borderColor: '#2563eb',
                    borderWidth: dynamicLineWidth, // 使用动态线宽
                    fill: false,
                    tension: chartConfig.tension,
                    pointRadius: 0,
                    order: 2
                }
            ];

            // 只有在数据点发生变化或重置缩放时，才重新计算坐标轴范围
            // 否则保留当前的缩放状态
            if (chart.options.animation.duration === 0) {
                // 首次加载或重置，确保坐标轴自动调整
                chart.options.scales.x.min = undefined;
                chart.options.scales.x.max = undefined;
                chart.options.scales.y.min = undefined;
                chart.options.scales.y.max = undefined;
            }

            // 启用动画
            chart.options.animation = { duration: 400 };

            chart.update();
        }

        // --- 拖动事件处理 ---
        let isDragging = false;
        let activePointIndex = -1;
        let animationFrameId = null;

        function getChartCoordinates(event) {
            const rect = chart.canvas.getBoundingClientRect();
            let clientX = event.clientX;
            let clientY = event.clientY;

            // 触屏事件处理
            if (event.touches && event.touches.length > 0) {
                clientX = event.touches[0].clientX;
                clientY = event.touches[0].clientY;
            }
            
            // 考虑canvas偏移量
            const x = clientX - rect.left;
            const y = clientY - rect.top;
            
            return { x, y };
        }

        function initDragHandling() {
            const canvas = document.getElementById('fittingChart');
            
            // 鼠标事件
            canvas.addEventListener('mousedown', startDrag);
            document.addEventListener('mousemove', drag);
            document.addEventListener('mouseup', endDrag);

            // 触屏事件
            canvas.addEventListener('touchstart', (e) => {
                e.preventDefault(); // 阻止默认的滚动/缩放行为
                startDrag(e);
            });
            document.addEventListener('touchmove', (e) => {
                e.preventDefault(); // 阻止默认的滚动/缩放行为
                drag(e);
            });
            document.addEventListener('touchend', endDrag);

            // 初始化光标样式
            canvas.style.cursor = dragEnabled ? 'grab' : 'default';
        }

        function startDrag(event) {
            if (!dragEnabled) return;
            const { x, y } = getChartCoordinates(event);
            const closest = findClosestPoint(x, y);

            if (closest) {
                isDragging = true;
                activePointIndex = closest.index;
                document.body.style.cursor = 'grabbing';
                document.body.style.userSelect = 'none'; // 阻止拖动时的文本选择
                
                // 禁用 Chart.js 内置的交互（如缩放、平移）
                if(chart) {
                    chart.options.plugins.zoom.pan.enabled = false;
                    chart.options.plugins.zoom.zoom.wheel.enabled = false;
                    chart.options.plugins.zoom.zoom.pinch.enabled = false;
                    chart.options.events = []; // 暂停图表交互
                }
            }
        }

        function drag(event) {
            if (!isDragging || activePointIndex === -1) return;
            
            // 使用 requestAnimationFrame 优化拖动性能
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
            }

            animationFrameId = requestAnimationFrame(() => {
                const { x, y } = getChartCoordinates(event);

                const newX = chart.scales.x.getValueForPixel(x);
                const newY = chart.scales.y.getValueForPixel(y);
                
                // 更新数据点
                points[activePointIndex][0] = parseFloat(newX.toFixed(4));
                points[activePointIndex][1] = parseFloat(newY.toFixed(4));

                // 仅更新散点图数据，不重新计算拟合，以保持流畅
                updateScatterPointsOnly();
            });
        }

        function endDrag() {
            if (isDragging) {
                isDragging = false;
                activePointIndex = -1;
                document.body.style.cursor = dragEnabled ? 'grab' : 'default';
                document.body.style.userSelect = ''; // 恢复文本选择

                // 恢复 Chart.js 内置的交互
                if(chart) {
                    chart.options.plugins.zoom.pan.enabled = true;
                    chart.options.plugins.zoom.zoom.wheel.enabled = true;
                    chart.options.plugins.zoom.zoom.pinch.enabled = true;
                    chart.options.events = ['mousemove', 'mouseout', 'click', 'touchstart', 'touchmove'];
                    chart.options.animation = { duration: 400 };
                }
                
                // 拖动结束后重新计算拟合
                updatePointsList();
                calculateAllFits();
            }
            if (animationFrameId) {
                cancelAnimationFrame(animationFrameId);
                animationFrameId = null;
            }
        }

        function findClosestPoint(x, y) {
            if (!chart) return null;
            const tolerance = 20; // 像素容差

            for (let i = 0; i < points.length; i++) {
                const point = points[i];
                const pixelX = chart.scales.x.getPixelForValue(point[0]);
                const pixelY = chart.scales.y.getPixelForValue(point[1]);

                const distance = Math.sqrt(Math.pow(x - pixelX, 2) + Math.pow(y - pixelY, 2));
                
                if (distance <= tolerance) {
                    return { index: i, point: point };
                }
            }
            return null;
        }
        
        // 只更新散点图数据，不重新计算拟合
        function updateScatterPointsOnly() {
            if (!chart) return;
            const scatterData = points.map(p => ({x: p[0], y: p[1]}));
            
            // 只更新散点图数据集
            chart.data.datasets[0].data = scatterData;
            
            // 使用更轻量的更新方式
            chart.update('none'); 

            // 更新左侧数据列表
            updatePointsList();
        }

        document.addEventListener('DOMContentLoaded', () => {
            // 检查系统主题偏好或本地存储
            const savedTheme = localStorage.getItem('theme');
            if (savedTheme === 'dark') {
                setTheme('dark');
            } else {
                setTheme('light');
            }
            
            initChart();
            initHorizontalResizer(); // 上下调节
            initVerticalResizer(); // 左右调节
            initializeExampleData();
            setupInputs();
            initDragHandling(); // 初始化拖动处理

            // 绑定拖动锁定按钮
            const lockBtn = document.getElementById('dragLockBtn');
            if (lockBtn) {
                lockBtn.onclick = () => {
                    dragEnabled = !dragEnabled;
                    lockBtn.textContent = dragEnabled ? '锁定拖动' : '解锁拖动';
                    lockBtn.style.background = dragEnabled ? 'var(--accent-color)' : '';
                    lockBtn.style.color = dragEnabled ? 'white' : '';
                    
                    // 更新图表光标样式
                    const canvas = document.getElementById('fittingChart');
                    canvas.style.cursor = dragEnabled ? 'grab' : 'default';
                    
                    if (!dragEnabled && isDragging) {
                        endDrag(); // 强制结束拖动状态
                    }
                };
            }
        });

        // --- 主题切换逻辑 ---
        function toggleTheme() {
            const currentTheme = document.documentElement.getAttribute('data-theme');
            const newTheme = currentTheme === 'dark' ? 'light' : 'dark';
            setTheme(newTheme);
        }

        function setTheme(theme) {
            document.documentElement.setAttribute('data-theme', theme);
            localStorage.setItem('theme', theme);
            
            const moonIcon = document.getElementById('moonIcon');
            const sunIcon = document.getElementById('sunIcon');

            if (moonIcon && sunIcon) {
                moonIcon.style.display = theme === 'dark' ? 'none' : 'block';
                sunIcon.style.display = theme === 'dark' ? 'block' : 'none';
            }

            // 重新初始化图表以应用新主题颜色
            if (chart) {
                chart.destroy();
                initChart();
                calculateAllFits(); // 重新计算并更新图表
            }
        }

        // --- 侧边栏和主区域拖动调整大小 ---

        // --- 纵向调节 (左右拖动) ---
        function initVerticalResizer() {
            const resizer = document.getElementById('verticalDragHandle');
            const mainLayout = document.getElementById('mainLayout');
            let isResizing = false;

            resizer.addEventListener('mousedown', (e) => {
                isResizing = true;
                document.body.style.cursor = 'col-resize';
                document.body.style.userSelect = 'none';
                if(chart) chart.options.events = []; // 暂停图表交互
            });

            document.addEventListener('mousemove', (e) => {
                if (!isResizing) return;
                
                const containerLeft = mainLayout.getBoundingClientRect().left;
                let newWidth = e.clientX - containerLeft;
                
                const maxW = window.innerWidth - 50; 
                
                // 限制最小和最大宽度
                if (newWidth < 20) newWidth = 20;
                if (newWidth > maxW) newWidth = maxW;

                mainLayout.style.gridTemplateColumns = `${newWidth}px 14px 1fr`;
                
                if(chart) chart.resize();
            });

            document.addEventListener('mouseup', () => {
                if (isResizing) {
                    isResizing = false;
                    document.body.style.cursor = '';
                    document.body.style.userSelect = '';
                    
                    if(chart) {
                        chart.options.events = ['mousemove', 'mouseout', 'click', 'touchstart', 'touchmove'];
                        chart.update('none');
                    }
                }
            });
        }

        // --- 横向调节 (上下拖动) ---
        function initHorizontalResizer() {
            const resizer = document.getElementById('horizontalDragHandle');
            const chartWrapper = document.getElementById('chartWrapper');
            const contentArea = document.getElementById('contentArea');
            let isResizing = false;

            resizer.addEventListener('mousedown', (e) => {
                isResizing = true;
                document.body.style.cursor = 'row-resize';
                document.body.style.userSelect = 'none';
                if(chart) chart.options.events = [];
            });

            document.addEventListener('mousemove', (e) => {
                if (!isResizing) return;
                
                const containerRect = contentArea.getBoundingClientRect();
                const offsetTop = containerRect.top;
                let newHeight = e.clientY - offsetTop;
                
                const minHeight = 20;
                const maxAvailableHeight = containerRect.height - 40; // 留出底部公式区最小高度

                if (newHeight < minHeight) newHeight = minHeight;
                if (newHeight > maxAvailableHeight) newHeight = maxAvailableHeight;
                
                chartWrapper.style.height = `${newHeight}px`;
                
                if(chart) chart.resize();
            });

            document.addEventListener('mouseup', () => {
                if (isResizing) {
                    isResizing = false;
                    document.body.style.cursor = '';
                    document.body.style.userSelect = '';
                    
                    if(chart) {
                        chart.options.events = ['mousemove', 'mouseout', 'click', 'touchstart', 'touchmove'];
                        chart.update('none');
                    }
                }
            });
        }
        
        // --- 图表缩放控制 ---
        function zoomChart(factor) {
            if (!chart || points.length === 0) return;

            const xScale = chart.scales.x;
            const yScale = chart.scales.y;

            // 1. 获取当前范围
            const currentXRange = xScale.max - xScale.min;
            const currentYRange = yScale.max - yScale.min;
            
            // 2. 获取当前中心点
            const currentXCenter = xScale.min + currentXRange / 2;
            const currentYCenter = yScale.min + currentYRange / 2;

            // 3. 计算新范围
            const newXRange = currentXRange * factor;
            const newYRange = currentYRange * factor;

            // 4. 设置新的坐标轴范围
            xScale.min = currentXCenter - newXRange / 2;
            xScale.max = currentXCenter + newXRange / 2;
            yScale.min = currentYCenter - newYRange / 2;
            yScale.max = currentYCenter + newYRange / 2;
            
            // 5. 更新缩放级别 (用于 visual scaling)
            if (initialXRange > 0) {
                // currentZoomLevel 存储的是 **当前数据范围 / 原始数据范围** 的比值
                // 范围越小 (放大效果)，currentZoomLevel 越小
                currentZoomLevel = newXRange / initialXRange;
            } else {
                currentZoomLevel = 1.0;
            }

            // 6. 强制更新图表 (调用 updateChart 来应用动态线宽/点半径)
            // 需要获取当前的拟合线数据和标签
            const currentFitPoints = chart.data.datasets[1].data.map(d => [d.x, d.y]);
            const currentLabel = chart.data.datasets[1].label;
            updateChart(points, currentFitPoints, currentLabel);
        }

        function resetZoom() {
            if (!chart) return;
            
            currentZoomLevel = 1.0; // 新增：重置缩放级别

            const xScale = chart.scales.x;
            const yScale = chart.scales.y;

            // 重置坐标轴范围
            xScale.min = undefined;
            xScale.max = undefined;
            yScale.min = undefined;
            yScale.max = undefined;
            
            // 更新图表 (需重新计算拟合，因为 calculateAllFits 会调用 updateChart)
            calculateAllFits();
        }

        // --- 数据点编辑功能 ---
        function editPoint(index) {
            if (editingIndex !== -1) {
                cancelEdit(editingIndex);
            }
            editingIndex = index;
            updatePointsList();
        }

        function saveEdit(index) {
            const xInput = document.getElementById(`editX_${index}`);
            const yInput = document.getElementById(`editY_${index}`);
            
            const newX = parseFloat(xInput.value);
            const newY = parseFloat(yInput.value);

            if (!isNaN(newX) && !isNaN(newY)) {
                points[index] = [newX, newY];
                points.sort((a, b) => a[0] - b[0]);
                editingIndex = -1;
                updatePointsList();
                calculateAllFits();
            } else {
                alert("请输入有效的数字");
            }
        }

        function cancelEdit(index) {
            editingIndex = -1;
            updatePointsList();
        }

        function setupInputs() {
            ['xInput', 'yInput'].forEach(id => {
                document.getElementById(id).addEventListener('keypress', (e) => {
                    if (e.key === 'Enter') {
                        addPoint();
                    }
                });
            });
        }

        function updatePointsList() {
            const container = document.getElementById('pointsList');
            let html = '';
            
            points.forEach((p, i) => {
                if (i === editingIndex) {
                    // 编辑模式
                    html += `
                    <div class="data-row editing" style="display:flex; gap: 8px; align-items:center;">
                        <input type="number" id="editX_${i}" value="${p[0]}" class="edit-input" step="any" placeholder="X">
                        <input type="number" id="editY_${i}" value="${p[1]}" class="edit-input" step="any" placeholder="Y">
                        <div class="edit-buttons">
                            <button class="edit-btn btn-primary" onclick="saveEdit(${i})">保存</button>
                            <button class="edit-btn btn-ghost" onclick="cancelEdit(${i})">取消</button>
                        </div>
                    </div>
                    `;
                } else {
                    // 显示模式
                    html += `
                    <div class="data-row" onclick="editPoint(${i})">
                        <span>x: ${p[0].toFixed(2)}</span>
                        <span>y: ${p[1].toFixed(2)}</span>
                        <button class="btn-ghost" onclick="event.stopPropagation(); removePoint(${i})">×</button>
                    </div>
                    `;
                }
            });

            container.innerHTML = html;
        }

        function exportTxt() {
            if (points.length === 0) {
                alert("当前没有数据可导出");
                return;
            }

            const content = points.map(p => `${p[0]},${p[1]}`).join('\n');
            const blob = new Blob([content], { type: "text/plain;charset=utf-8" });
            const url = window.URL.createObjectURL(blob);
            
            const a = document.createElement('a');
            a.href = url;
            a.download = `fitting_data_${new Date().toISOString().slice(0,10)}.txt`;
            
            document.body.appendChild(a);
            a.click();
            
            document.body.removeChild(a);
            window.URL.revokeObjectURL(url);
        }

        function importTxt(inputElement) {
            const file = inputElement.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = function(e) {
                const text = e.target.result;
                let addedCount = 0;
                
                const tokens = text.trim().split(/[\s\n]+/);
                
                tokens.forEach(token => {
                    if (token.includes(',')) {
                        const parts = token.split(',');
                        if (parts.length === 2) {
                            const x = parseFloat(parts[0]);
                            const y = parseFloat(parts[1]);

                            if (!isNaN(x) && !isNaN(y)) {
                                points.push([x, y]);
                                addedCount++;
                            }
                        }
                    }
                });

                if (addedCount > 0) {
                    points.sort((a, b) => a[0] - b[0]);
                    updatePointsList();
                    calculateAllFits();
                    console.log(`已成功导入 ${addedCount} 个数据点`);
                } else {
                    alert("未在文件中找到有效的格式数据 (x,y)");
                }
                
                inputElement.value = ''; // 清空 file input 避免重复导入
            };
            
            reader.readAsText(file);
        }

    </script>

    <script src="https://cdn.jsdelivr.net/npm/katex@0.16.0/dist/katex.min.js"></script>
    <script src="https://cdn.jsdelivr.npm/katex@0.16.0/dist/contrib/auto-render.min.js" 
        onload="renderMathInElement(document.body);"
        integrity="sha384-yq2eEa7T80cR+L9c7K9r9h9a9q9z9p9f9d9c9b9a9q9p9r9s9t9u9v9w9x9y9z9a" 
        crossorigin="anonymous">
    </script>
</body>
</html>